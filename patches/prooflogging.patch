diff -ruN src_tmp/core/Main.C src/core/Main.C
--- src_tmp/core/Main.C	2021-12-24 13:23:17.650468327 +0100
+++ src/core/Main.C	2021-12-24 13:20:00.144128747 +0100
@@ -27,6 +27,7 @@
 #include <zlib.h>
 
 #include "Solver.h"
+#include "Prooflogger.h"
 
 /*************************************************************************************/
 #ifdef _MSC_VER
@@ -131,18 +132,18 @@
     return neg ? -val : val; }
 
 template<class B>
-static void readClause(B& in, Solver& S, vec<Lit>& lits, 
+static void readClause(B& in, Solver& S, Prooflogger& PL, vec<Lit>& lits, 
 		       int nbvar, int top, int& nbsoft) { // koshi 10.01.04
 
-    int     parsed_lit, var;
+    int parsed_lit, var, weight;
     lits.clear();
-    parsed_lit = parseInt(in); // koshi 10.01.04
-    if (parsed_lit == 1) { // soft clause
+    weight = parseInt(in); // koshi 10.01.04
+    if (weight == 1) { // soft clause
       nbsoft++;
       lits.push(Lit(S.newVar()));
-    } else if (parsed_lit != top) { // weight of hard clause must be top
+    } else if (weight != top) { // weight of hard clause must be top
       reportf("Unexpected weight %c\n", *in), exit(3);
-    }
+    } else weight = top;
 
     for (;;){
         parsed_lit = parseInt(in);
@@ -151,6 +152,9 @@
 	// koshi 10.01.04        while (var >= S.nVars()) S.newVar();
         lits.push( (parsed_lit > 0) ? Lit(var) : ~Lit(var) );
     }
+
+    // Write the clause to the OPB file
+    PL.write_OPB_constraint(lits, weight);
 }
 
 template<class B>
@@ -163,42 +167,52 @@
 
 
 template<class B>
-static void parse_DIMACS_main(B& in, Solver& S, 
+static void parse_DIMACS_main(B& in, Solver& S, Prooflogger &PL, 
 			      int& out_nbvar, int& out_top, int& out_nbsoft) {
     vec<Lit> lits;
+    int vars, clauses;
+
+    // Read header
+    skipWhitespace(in);
+    if (*in == 'p'){
+	     if (match(in, "p wcnf")){ // koshi 10.01.04
+            vars    = parseInt(in);
+            clauses = parseInt(in);
+		    int top     = parseInt(in);
+		    out_nbvar   = vars;
+		    out_top     = top;
+            reportf("|  Number of variables:    %-12d                                       |\n", vars);
+            reportf("|  Number of clauses:      %-12d                                       |\n", clauses);
+            reportf("|  Weight of hard clauses: %-12d                                       |\n", top);
+		    while (vars > S.nVars()) S.newVar();
+        } else {
+            reportf("PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
+        }
+    } else reportf("PARSE ERROR! No header given!");
+
+    // Read clauses
     for (;;){
         skipWhitespace(in);
         if (*in == EOF)
             break;
-        else if (*in == 'p'){
-	  if (match(in, "p wcnf")){ // koshi 10.01.04
-                int vars    = parseInt(in);
-                int clauses = parseInt(in);
-		int top     = parseInt(in);
-		out_nbvar   = vars;
-		out_top     = top;
-                reportf("|  Number of variables:    %-12d                                       |\n", vars);
-                reportf("|  Number of clauses:      %-12d                                       |\n", clauses);
-                reportf("|  Weight of hard clauses: %-12d                                       |\n", top);
-		while (vars > S.nVars()) S.newVar();
-            }else{
-                reportf("PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
-            }
-        } else if (*in == 'c' || *in == 'p')
-            skipLine(in);
-        else
-	  readClause(in, S, lits, out_nbvar,out_top,out_nbsoft),
+        else if (*in == 'c' || *in == 'p') skipLine(in);
+        else {
+	        readClause(in, S, PL, lits, out_nbvar,out_top,out_nbsoft),
             S.addClause(lits);
+        }
     }
     reportf("|  Number of soft clauses: %-12d                                       |\n", out_nbsoft);
+    PL.write_proof_header(clauses);
+    PL.write_OPB_header(vars, clauses);
+    PL.write_minimise(out_nbvar, out_nbsoft);
 }
 
 // Inserts problem into solver.
 //
-static void parse_DIMACS(gzFile input_stream, Solver& S, 
+static void parse_DIMACS(gzFile input_stream, Solver& S, Prooflogger &PL, 
 			 int& out_nbvar, int& out_top, int& out_nbsoft) { // koshi 10.01.04
     StreamBuffer in(input_stream);
-    parse_DIMACS_main(in, S, out_nbvar, out_top, out_nbsoft); }
+    parse_DIMACS_main(in, S, PL, out_nbvar, out_top, out_nbsoft); }
 
 
 //=================================================================================================
@@ -236,6 +250,7 @@
     reportf("  -decay         = <num> [ 0 - 1 ]\n");
     reportf("  -rnd-freq      = <num> [ 0 - 1 ]\n");
     reportf("  -verbosity     = {0,1,2}\n");
+    reportf("  -proof-file    = /path/to/proof_file.proof (default: maxsat_proof.proof)");
     reportf("\n");
 }
 
@@ -249,9 +264,11 @@
         return NULL;
 }
 
+
+
 // koshi 10.01.08
 void genCardinals(int from, int to, 
-		  Solver& S, vec<Lit>& lits, vec<Lit>& linkingVar) {
+		  Solver& S, Prooflogger& PL, vec<Lit>& lits, vec<Lit>& linkingVar) {
   int inputSize = to - from + 1;
   linkingVar.clear();
 
@@ -261,42 +278,52 @@
   Var varZero = S.newVar();
   Var varLast = S.newVar();
 
+  // First
   lits.clear(); lits.push(Lit(varZero)); S.addClause(lits);
+  PL.write_sub_red(lits, true);
+
+  // Last
   lits.clear(); lits.push(~Lit(varLast)); S.addClause(lits);
+  PL.write_sub_red(lits, false);
+
 
   if (inputSize > 2) {
     int middle = inputSize/2;
-    genCardinals(from, from+middle, S,lits,linkingAlpha);
-    genCardinals(from+middle+1, to, S,lits,linkingBeta);
+    genCardinals(from, from+middle, S,PL,lits,linkingAlpha);
+    genCardinals(from+middle+1, to, S,PL,lits,linkingBeta);
   } else if (inputSize == 2) {
-    genCardinals(from, from, S,lits,linkingAlpha);
-    genCardinals(to, to, S,lits,linkingBeta);
+    genCardinals(from, from, S,PL,lits,linkingAlpha);
+    genCardinals(to, to, S,PL,lits,linkingBeta);
   }
   if (inputSize == 1) {
     linkingVar.push(Lit(varZero));
     linkingVar.push(Lit(from));
     linkingVar.push(Lit(varLast));
   } else { // inputSize >= 2
+    PL.write_comment("- Node clauses:");
     linkingVar.push(Lit(varZero));
     for (int i = 0; i < inputSize; i++) linkingVar.push(Lit(S.newVar()));
     linkingVar.push(Lit(varLast));
     for (int sigma = 0; sigma <= inputSize; sigma++) {
       for (int alpha = 0; alpha < linkingAlpha.size()-1; alpha++) {
-	int beta = sigma - alpha;
-	if (0 <= beta && beta < linkingBeta.size()-1) { // create constraints
-	  lits.clear();
-	  lits.push(~linkingAlpha[alpha]);
-	  lits.push(~linkingBeta[beta]);
-	  lits.push(linkingVar[sigma]);
-	  S.addClause(lits);
-	  lits.clear();
-	  lits.push(linkingAlpha[alpha+1]);
-	  lits.push(linkingBeta[beta+1]);
-	  lits.push(~linkingVar[sigma+1]);
-	  S.addClause(lits);
-	}
+	    int beta = sigma - alpha;
+	    if (0 <= beta && beta < linkingBeta.size()-1) { // create constraints
+	      lits.clear();
+	      lits.push(~linkingAlpha[alpha]);
+	      lits.push(~linkingBeta[beta]);
+	      lits.push(linkingVar[sigma]);
+          PL.write_sub_red(lits, true);
+	      S.addClause(lits);
+	      lits.clear();
+	      lits.push(linkingAlpha[alpha+1]);
+	      lits.push(linkingBeta[beta+1]);
+	      lits.push(~linkingVar[sigma+1]);
+          PL.write_sub_red(lits, false);
+	      S.addClause(lits);
+	    }
       }
     }
+    PL.write_comment("-------------------------------------------");
   }
   linkingAlpha.clear();
   linkingBeta.clear();
@@ -304,10 +331,10 @@
 
 int main(int argc, char** argv)
 {
-    Solver      S;
+    Prooflogger PL;
+    Solver      S(&PL);
     S.verbosity = 1;
 
-
     int         i, j;
     const char* value;
     for (i = j = 0; i < argc; i++){
@@ -347,6 +374,15 @@
             printUsage(argv);
             exit(0);
 
+        } else if ((value = hasPrefix(argv[i], "-proof-file="))) {
+            PL.set_proof_name(value);
+
+        } else if ((value = hasPrefix(argv[i], "-opb-file="))) {
+            PL.set_OPB_name(value);
+
+        }else if (strcmp(argv[i], "-mn") == 0 || strcmp(argv[i], "-meaningful_names") == 0 || strcmp(argv[i], "--meaningful_names") == 0){
+            PL.meaningful_names = true;
+
         }else if (strncmp(argv[i], "-", 1) == 0){
             reportf("ERROR! unknown flag %s\n", argv[i]);
             exit(0);
@@ -357,7 +393,7 @@
     argc = j;
 
 
-    reportf("This is QMaxSAT 0.1 based on MiniSat 2.0 beta\n");
+    reportf("This is QMaxSAT 0.1 based on MiniSat 2.0 beta, extended for prooflogging\n");
 #if defined(__linux__)
     fpu_control_t oldcw, newcw;
     _FPU_GETCW(oldcw); newcw = (oldcw & ~_FPU_EXTENDED) | _FPU_DOUBLE; _FPU_SETCW(newcw);
@@ -376,6 +412,9 @@
     if (in == NULL)
         reportf("ERROR! Could not open file: %s\n", argc == 1 ? "<stdin>" : argv[1]), exit(1);
 
+    // Open OPB file
+    PL.open_OPB();
+
     reportf("============================[ Problem Statistics ]=============================\n");
     reportf("|                                                                             |\n");
 
@@ -383,8 +422,18 @@
     int nbvar  = 0; // number of original variables
     int top    = 0; // weight of hard clause
     int nbsoft = 0; // number of soft clauses
-    parse_DIMACS(in, S, nbvar, top, nbsoft);
+    parse_DIMACS(in, S, PL, nbvar, top, nbsoft);
+    
+    // Initialise PL constraint counter
+    PL.constraint_counter = S.nClauses();
+
+    // Close input file
     gzclose(in);
+
+    // Close written OPB file
+    PL.close_OPB();
+
+    // Open output file
     FILE* res = (argc >= 3) ? fopen(argv[2], "wb") : NULL;
 
     double parse_time = cpuTime() - cpu_time;
@@ -393,6 +442,8 @@
     if (!S.simplify()){
         reportf("Solved by unit propagation\n");
         if (res != NULL) fprintf(res, "UNSAT\n"), fclose(res);
+        PL.derived_empty_clause();
+        PL.write_proof();
         printf("UNSATISFIABLE\n");
         exit(20);
     }
@@ -407,21 +458,41 @@
       lcnt++;
       int answerNew = 0;
       for (int i = nbvar; i < nbvar+nbsoft; i++) // count the number of
-	if (S.model[i] == l_True) answerNew++;   // unsatisfied soft clauses
-      if (lcnt == 1) { // first model: generate cardinal constraints
-	genCardinals(nbvar,nbvar+nbsoft-1, S,lits,linkingVar);
-	for (int i = answerNew; i < linkingVar.size()-1; i++) {
-	  lits.clear();
-	  lits.push(~linkingVar[i]);
-	  S.addClause(lits);
-	}
-	answer = answerNew;
-      } else { // lcnt > 1 
-	for (int i = answerNew; i < answer; i++) {
-	  lits.clear();
-	  lits.push(~linkingVar[i]);
-	  S.addClause(lits);
-	}
+	    if (S.model[i] == l_True) answerNew++;   // unsatisfied soft clauses
+      if (lcnt == 1) { // first model: generate cardinality constraints
+        PL.write_comment("==============================================================");
+        PL.write_comment("First model found:"); 
+        PL.write_bound_update(S.model);
+        PL.write_comment("==============================================================");
+        PL.write_comment("Cardinality encoding:"); 
+	    genCardinals(nbvar,nbvar+nbsoft-1, S,PL,lits,linkingVar);
+        //PL.write_comment("==============================================================");
+        //PL.write_comment("Linking variables order:"); 
+        //PL.write_order(linkingVar);
+        PL.write_comment("==============================================================");
+        PL.write_comment("Constraining through linking variables:"); 
+	    for (int i = answerNew; i < linkingVar.size()-1; i++) {
+	      lits.clear();
+	      lits.push(~linkingVar[i]);
+          PL.write_learnt_clause(lits);
+	      S.addClause(lits);
+	    }
+        PL.write_comment("==============================================================");
+        answer = answerNew;
+    } else { // lcnt > 1 
+        PL.write_comment("==============================================================");
+        PL.write_comment("New model found:"); 
+        PL.write_bound_update(S.model);
+        PL.write_comment("==============================================================");
+        PL.write_comment("Constraining through linking variables:"); 
+	    for (int i = answerNew; i < answer; i++) {
+	      lits.clear();
+	      lits.push(~linkingVar[i]);
+          PL.write_learnt_clause(lits);
+	      S.addClause(lits);
+	    }
+        PL.write_comment("==============================================================");
+
 	answer = answerNew;
       }
       reportf("Current answer = %d\n",answer);
@@ -439,10 +510,11 @@
                 if (S.model[i] != l_Undef)
                     fprintf(res, "%s%s%d", (i==0)?"":" ", (S.model[i]==l_True)?"":"-", i+1);
             fprintf(res, " 0\n");
-        }else
+        } else
             fprintf(res, "UNSAT\n");
         fclose(res);
     }
+    PL.write_proof();
 
 #ifdef NDEBUG
     exit(ret ? 10 : 20);     // (faster than "return", which will invoke the destructor for 'Solver')
diff -ruN src_tmp/core/Prooflogger.C src/core/Prooflogger.C
--- src_tmp/core/Prooflogger.C	1970-01-01 01:00:00.000000000 +0100
+++ src/core/Prooflogger.C	2021-12-24 13:23:13.878425936 +0100
@@ -0,0 +1,188 @@
+#include "Prooflogger.h"
+
+//=================================================================================================
+// Proof writing methods
+
+
+void Prooflogger::write_proof_header(int nbclause) {
+    proof << "pseudo-Boolean proof version 1.0\n";
+    proof << "f " << nbclause << "\n";
+}
+
+void Prooflogger::write_comment(const char* comment) {
+    proof<< "* " << comment << "\n";
+}
+
+void Prooflogger::derived_empty_clause() {
+    proof<< "u >= 1;\n";
+    constraint_counter++;
+    write_contradiction();
+}
+
+const char* Prooflogger::literal_symbol(int var) {
+    if(var + 1 > formula_length + n_variables) return "y";
+    else return "x";
+}
+
+void Prooflogger::write_sub_red(vec<Lit>& definition, bool ass) {
+    int first = var(definition[0]);
+    int second = var(definition[1]); 
+    int third = var(definition[definition.size()-1]);
+
+    // If variable does not already have a meaningful name
+    if(meaningful_name_LB.find(third) == meaningful_name_LB.end()) {
+
+        // First two are x's
+        if(first+1 <= formula_length + n_variables && second <= formula_length + n_variables) {
+            meaningful_name_LB[third] = first+1;
+            meaningful_name_UB[third] = second+1;
+            meaningful_name_n[third] = 1;
+        }
+
+        // First is an x
+        else if(first+1 <= formula_length + n_variables) {
+            meaningful_name_LB[third] = first+1;
+            meaningful_name_n[third] = 2;
+        }
+
+        // First has a simplified name
+        else if(meaningful_name_UB.find(first) != meaningful_name_UB.end()) {
+
+            // Second is an x
+            if(second+1 <= formula_length + n_variables) {
+                meaningful_name_LB[third] = meaningful_name_LB[first];
+                meaningful_name_UB[third] = second+1;
+                meaningful_name_n[third] = meaningful_name_n[first];
+
+            // Second is a y
+            } else {
+                meaningful_name_LB[third] = meaningful_name_LB[first];
+                meaningful_name_UB[third] = meaningful_name_UB[first]+1;
+                meaningful_name_n[third] = meaningful_name_n[first]+1;
+            }
+        }
+
+    // Still need upper bound
+    } else if(meaningful_name_UB.find(third) == meaningful_name_UB.end()) {
+        meaningful_name_UB[third] = second+1;
+    }
+
+    // Write sub red line
+    std::string variable;
+    proof<< "red ";
+    for (int i = 0; i < definition.size(); i++) {
+
+        // Define variable name
+        variable = literal_symbol(var(definition[i])) + std::to_string(var(definition[i])+1);
+
+        // Write variable
+        if (sign(definition[i]) == 1)
+            proof<< "1 ~" << variable << " ";
+        else
+            proof<< "1 " << variable << " ";
+    }
+    proof<< " >= 1; " << variable << " -> " << std::to_string(sign(definition[definition.size()-1]) == 0) << "\n";
+    constraint_counter++;
+}
+
+void Prooflogger::write_bound_update(vec<lbool>& model) {
+    const char* symbol;
+    proof<< "o ";
+
+    for(int i = 0; i < model.size(); i++) {
+        symbol = literal_symbol(i);
+        if(model[i] == l_True) proof << symbol << i+1 << " ";
+        else if(model[i] == l_False) proof << "~" << symbol << i+1 << " ";
+    }
+    proof << "\n";
+
+    // Veripb automatically adds an improvement constraint so counter needs to be incremented
+    constraint_counter++;
+}
+
+void Prooflogger::write_learnt_clause(vec<Lit>& clause) {
+    const char* symbol;
+    proof << "u ";
+    for (int i = 0; i < clause.size(); i++) {
+        symbol = literal_symbol(var(clause[i]));
+        if (sign(clause[i]) == 1)
+            proof << "1 ~" << symbol << var(clause[i]) + 1 << " ";
+        else
+            proof << "1 " << symbol << var(clause[i]) + 1 << " ";
+    }
+    proof << " >= 1;\n";
+    constraint_counter++;
+}
+
+void Prooflogger::write_contradiction() {
+    proof << "c " << constraint_counter << "\n";
+}
+
+void Prooflogger::write_delete(int number) {
+    proof << "d " << number << "\n";
+    constraint_counter--;
+}
+
+void Prooflogger::write_proof() {
+
+    if(meaningful_names) {
+
+        // Loop over all variables that have a meaningful name
+        std::string proof_string;
+        std::string simplified_name;
+        std::string to_replace;
+        int lb,ub,n;
+        for(std::map<int,int>::iterator it = meaningful_name_LB.begin(); it != meaningful_name_LB.end(); it++) {
+            proof_string = proof.str();
+
+            lb = meaningful_name_LB[it->first];
+            ub = meaningful_name_UB[it->first];
+            n = meaningful_name_n[it->first];
+            simplified_name = "v" + std::to_string(n) + "_x" + std::to_string(lb) + "_x" + std::to_string(ub); 
+            to_replace = "y" + std::to_string(it->first+1); 
+
+            // Replace them with their meaningful name
+            proof_string = std::regex_replace(proof_string, std::regex(to_replace), simplified_name);
+
+            // Save as proof
+            proof.str(proof_string);
+        }
+    }
+
+    // Write proof to proof file
+    std::ofstream proof_file(proof_file_name);
+    proof_file << proof.rdbuf();
+
+    // Close
+    proof_file.close();
+}
+
+//=================================================================================================
+// OPB writing methods
+
+void Prooflogger::write_OPB_header(int nbvar, int nbclause) {
+    formula_length = nbclause;
+    n_variables = nbvar;
+    OPB_file << "* #variable= " << nbvar+nbclause << " #constraint= " << nbclause << "\n";
+    OPB_file << "*\n* This MaxSAT instance was automatically generated.\n*\n";
+}
+
+void Prooflogger::write_minimise(int start_var, int num) {
+    if(num > 0) {
+        OPB_file << "min: ";
+        for(int i = start_var+1; i < start_var+num+1; i++) {
+            OPB_file << "1 x" << i << " ";
+        } 
+        OPB_file << ";\n";
+    }
+}
+
+void Prooflogger::write_OPB_constraint(vec<Lit>& constraint, int weight) {
+    for (int i = 0; i < constraint.size(); i++) {
+        if (sign(constraint[i]) == 1)
+            constraints << "1 ~x" << var(constraint[i]) + 1 << " ";
+        else
+            constraints << "1 x" << var(constraint[i]) + 1 << " ";
+    }
+    constraints << " >= " << weight << " ;\n";
+}
diff -ruN src_tmp/core/Prooflogger.h src/core/Prooflogger.h
--- src_tmp/core/Prooflogger.h	1970-01-01 01:00:00.000000000 +0100
+++ src/core/Prooflogger.h	2021-12-24 13:22:58.830256032 +0100
@@ -0,0 +1,79 @@
+#ifndef Prooflogger_h
+#define Prooflogger_h
+
+#include <cstdio>
+#include <fstream>
+#include <iostream>
+#include <sstream>
+#include <map>
+#include <string>
+#include <regex>
+
+#include "Vec.h"
+#include "Heap.h"
+#include "Alg.h"
+
+#include "SolverTypes.h"
+
+
+//=================================================================================================
+// Prooflogger -- the main class:
+
+
+class Prooflogger {
+public:
+
+    // Formula number of clauses and number of variables
+    //
+    int formula_length = 0;
+    int n_variables = 0;
+
+    // Constraint counter
+    //
+    int constraint_counter = 0;
+
+    // Simplified constraint store
+    // 
+    std::map<int, int> simplified_constraint_store;
+
+    // Meaningful variable names
+    bool meaningful_names = false;
+    std::map<int, int> meaningful_name_LB;
+    std::map<int, int> meaningful_name_UB;
+    std::map<int, int> meaningful_name_n;
+
+    // Proof file
+    std::stringstream proof;
+    const char *proof_file_name = "maxsat_proof.pdb";
+    void set_proof_name             (const char* name) {proof_file_name = name;};
+    void write_proof                ();
+
+    void write_proof_header         (int nbclause);
+    void write_order                (vec<Lit>& linkingVarint);
+    void write_comment              (const char* comment);
+    void derived_empty_clause       ();
+    const char* literal_symbol      (int var); 
+    void write_learnt_clause        (vec<Lit>& clause);
+    void write_sub_red              (vec<Lit>& definition, bool ass);
+    void write_dom                  (vec<Lit>& linkingVar, int start, int stop); 
+    void write_bound_update         (vec<lbool>& model); 
+    void write_constraint           (vec<Lit>& clause);
+    void write_contradiction        ();
+    void write_delete               (int number);
+    void store                      (Lit literal);
+
+    // OPB file
+    std::ofstream OPB_file;
+    std::stringstream constraints;
+    const char *OPB_file_name = "maxsat_problem.opb";
+    void open_OPB                 ()                   {OPB_file.open(OPB_file_name);};
+    void close_OPB                ()                   {OPB_file << constraints.rdbuf(); OPB_file.close();};
+    void set_OPB_name             (const char* name)   {OPB_file_name = name;};
+
+    void write_OPB_header         (int nbvar, int nbclause);
+    void write_minimise           (int start_var, int num);
+    void write_OPB_constraint     (vec<Lit>& constraint, int weight);
+};
+
+//=================================================================================================
+#endif
\ No newline at end of file
diff -ruN src_tmp/core/Solver.C src/core/Solver.C
--- src_tmp/core/Solver.C	2021-12-24 13:23:17.650468327 +0100
+++ src/core/Solver.C	2021-12-22 16:00:12.341568535 +0100
@@ -26,7 +26,7 @@
 // Constructor/Destructor:
 
 
-Solver::Solver() :
+Solver::Solver(Prooflogger *PL) :
 
     // Parameters: (formerly in 'SearchParams')
     var_decay(1 / 0.95), clause_decay(1 / 0.999), random_var_freq(0.02)
@@ -53,6 +53,10 @@
   , random_seed      (91648253)
   , progress_estimate(0)
   , remove_satisfied (true)
+
+  // Prooflogger
+  //
+  , PL(PL)
 {}
 
 
@@ -544,7 +548,7 @@
 |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
 |    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
 |________________________________________________________________________________________________@*/
-lbool Solver::search(int nof_conflicts, int nof_learnts)
+lbool Solver::search(int nof_conflicts, int nof_learnts) 
 {
     assert(ok);
     int         backtrack_level;
@@ -560,12 +564,19 @@
         if (confl != NULL){
             // CONFLICT
             conflicts++; conflictC++;
-            if (decisionLevel() == 0) return l_False;
+            if (decisionLevel() == 0) {
+                PL->derived_empty_clause();
+                return l_False;
+            }
 
             first = false;
 
             learnt_clause.clear();
             analyze(confl, learnt_clause, backtrack_level);
+
+            // Write the learnt clause to the proof file
+            PL->write_learnt_clause(learnt_clause);
+
             cancelUntil(backtrack_level);
             assert(value(learnt_clause[0]) == l_Undef);
 
@@ -592,8 +603,10 @@
                 return l_Undef; }
 
             // Simplify the set of problem clauses:
-            if (decisionLevel() == 0 && !simplify())
+            if (decisionLevel() == 0 && !simplify()) {
+                PL->derived_empty_clause();
                 return l_False;
+            }
 
             if (nof_learnts >= 0 && learnts.size()-nAssigns() >= nof_learnts)
                 // Reduce the set of learnt clauses:
@@ -654,7 +667,10 @@
     model.clear();
     conflict.clear();
 
-    if (!ok) return false;
+    if (!ok) {
+        PL->derived_empty_clause();
+        return false;
+    }
 
     assumps.copyTo(assumptions);
 
diff -ruN src_tmp/core/Solver.h src/core/Solver.h
--- src_tmp/core/Solver.h	2021-12-24 13:23:17.650468327 +0100
+++ src/core/Solver.h	2021-12-01 11:33:19.867138205 +0100
@@ -21,12 +21,15 @@
 #define Solver_h
 
 #include <cstdio>
+#include <fstream>
+#include <iostream>
 
 #include "Vec.h"
 #include "Heap.h"
 #include "Alg.h"
 
 #include "SolverTypes.h"
+#include "Prooflogger.h"
 
 
 //=================================================================================================
@@ -38,9 +41,13 @@
 
     // Constructor/Destructor:
     //
-    Solver();
+    Solver(Prooflogger *PL);
     ~Solver();
 
+    // Proof logging:
+    //
+    Prooflogger* PL;
+
     // Problem specification:
     //
     Var     newVar    (bool polarity = true, bool dvar = true); // Add a new variable with parameters specifying variable mode.
@@ -146,19 +153,19 @@
 
     // Main internal methods:
     //
-    void     insertVarOrder   (Var x);                                                 // Insert a variable in the decision order priority queue.
-    Lit      pickBranchLit    (int polarity_mode, double random_var_freq);             // Return the next decision variable.
-    void     newDecisionLevel ();                                                      // Begins a new decision level.
-    void     uncheckedEnqueue (Lit p, Clause* from = NULL);                            // Enqueue a literal. Assumes value of literal is undefined.
-    bool     enqueue          (Lit p, Clause* from = NULL);                            // Test if fact 'p' contradicts current state, enqueue otherwise.
-    Clause*  propagate        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
-    void     cancelUntil      (int level);                                             // Backtrack until a certain level.
-    void     analyze          (Clause* confl, vec<Lit>& out_learnt, int& out_btlevel); // (bt = backtrack)
-    void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
-    bool     litRedundant     (Lit p, uint32_t abstract_levels);                       // (helper method for 'analyze()')
-    lbool    search           (int nof_conflicts, int nof_learnts);                    // Search for a given number of conflicts.
-    void     reduceDB         ();                                                      // Reduce the set of learnt clauses.
-    void     removeSatisfied  (vec<Clause*>& cs);                                      // Shrink 'cs' to contain only non-satisfied clauses.
+    void     insertVarOrder   (Var x);                                                  // Insert a variable in the decision order priority queue.
+    Lit      pickBranchLit    (int polarity_mode, double random_var_freq);              // Return the next decision variable.
+    void     newDecisionLevel ();                                                       // Begins a new decision level.
+    void     uncheckedEnqueue (Lit p, Clause* from = NULL);                             // Enqueue a literal. Assumes value of literal is undefined.
+    bool     enqueue          (Lit p, Clause* from = NULL);                             // Test if fact 'p' contradicts current state, enqueue otherwise.
+    Clause*  propagate        ();                                                       // Perform unit propagation. Returns possibly conflicting clause.
+    void     cancelUntil      (int level);                                              // Backtrack until a certain level.
+    void     analyze          (Clause* confl, vec<Lit>& out_learnt, int& out_btlevel);  // (bt = backtrack)
+    void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                          // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
+    bool     litRedundant     (Lit p, uint32_t abstract_levels);                        // (helper method for 'analyze()')
+    lbool    search           (int nof_conflicts, int nof_learnts);                     // Search for a given number of conflicts.
+    void     reduceDB         ();                                                       // Reduce the set of learnt clauses.
+    void     removeSatisfied  (vec<Clause*>& cs);                                       // Shrink 'cs' to contain only non-satisfied clauses.
 
     // Maintaining Variable/Clause activity:
     //
