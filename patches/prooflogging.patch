diff -ruN src_tmp/core/Main.C src/core/Main.C
--- src_tmp/core/Main.C	2022-02-07 14:54:10.164496200 +0100
+++ src/core/Main.C	2022-02-07 12:18:01.283305500 +0100
@@ -27,6 +27,7 @@
 #include <zlib.h>
 
 #include "Solver.h"
+#include "Prooflogger.h"
 
 /*************************************************************************************/
 #ifdef _MSC_VER
@@ -131,18 +132,18 @@
     return neg ? -val : val; }
 
 template<class B>
-static void readClause(B& in, Solver& S, vec<Lit>& lits, 
+static void readClause(B& in, Solver& S, Prooflogger& PL, vec<Lit>& lits, 
 		       int nbvar, int top, int& nbsoft) { // koshi 10.01.04
 
-    int     parsed_lit, var;
+    int parsed_lit, var, weight;
     lits.clear();
-    parsed_lit = parseInt(in); // koshi 10.01.04
-    if (parsed_lit == 1) { // soft clause
+    weight = parseInt(in); // koshi 10.01.04
+    if (weight == 1) { // soft clause
       nbsoft++;
       lits.push(Lit(S.newVar()));
-    } else if (parsed_lit != top) { // weight of hard clause must be top
+    } else if (weight != top) { // weight of hard clause must be top
       reportf("Unexpected weight %c\n", *in), exit(3);
-    }
+    } else weight = top;
 
     for (;;){
         parsed_lit = parseInt(in);
@@ -151,6 +152,9 @@
 	// koshi 10.01.04        while (var >= S.nVars()) S.newVar();
         lits.push( (parsed_lit > 0) ? Lit(var) : ~Lit(var) );
     }
+
+    // Write the clause to the OPB file
+    // PL.write_OPB_constraint(lits); // wcnf file read directly by veripb
 }
 
 template<class B>
@@ -163,42 +167,56 @@
 
 
 template<class B>
-static void parse_DIMACS_main(B& in, Solver& S, 
+static void parse_DIMACS_main(B& in, Solver& S, Prooflogger &PL, 
 			      int& out_nbvar, int& out_top, int& out_nbsoft) {
     vec<Lit> lits;
+    int vars, clauses;
+
+    // Read header
+    skipWhitespace(in);
+    while(*in == 'c') skipLine(in);
+    if (*in == 'p'){
+	     if (match(in, "p wcnf")){ // koshi 10.01.04
+            vars    = parseInt(in);            
+            clauses = parseInt(in);            
+		    int top     = parseInt(in);
+		    out_nbvar   = vars;
+		    out_top     = top;
+            reportf("|  Number of variables:    %-12d                                       |\n", vars);
+            reportf("|  Number of clauses:      %-12d                                       |\n", clauses);
+            reportf("|  Weight of hard clauses: %-12d                                       |\n", top);
+		    while (vars > S.nVars()) S.newVar();
+        } else {
+            reportf("PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
+        }
+    } else reportf("PARSE ERROR! No header given!");
+
+    // Read clauses
     for (;;){
         skipWhitespace(in);
         if (*in == EOF)
             break;
-        else if (*in == 'p'){
-	  if (match(in, "p wcnf")){ // koshi 10.01.04
-                int vars    = parseInt(in);
-                int clauses = parseInt(in);
-		int top     = parseInt(in);
-		out_nbvar   = vars;
-		out_top     = top;
-                reportf("|  Number of variables:    %-12d                                       |\n", vars);
-                reportf("|  Number of clauses:      %-12d                                       |\n", clauses);
-                reportf("|  Weight of hard clauses: %-12d                                       |\n", top);
-		while (vars > S.nVars()) S.newVar();
-            }else{
-                reportf("PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
-            }
-        } else if (*in == 'c' || *in == 'p')
-            skipLine(in);
-        else
-	  readClause(in, S, lits, out_nbvar,out_top,out_nbsoft),
+        else if (*in == 'c' || *in == 'p') skipLine(in);
+        else {
+	        readClause(in, S, PL, lits, out_nbvar,out_top,out_nbsoft),
             S.addClause(lits);
+        }
     }
     reportf("|  Number of soft clauses: %-12d                                       |\n", out_nbsoft);
+    PL.n_variables = vars+out_nbsoft;
+    PL.formula_length = clauses;
+    PL.write_proof_header(clauses);
+    
+    // PL.write_OPB_header(vars, out_nbsoft, clauses); // wcnf file read directly by veripb
+    // PL.write_minimise(out_nbvar, out_nbsoft);  // wcnf file read directly by veripb
 }
 
 // Inserts problem into solver.
 //
-static void parse_DIMACS(gzFile input_stream, Solver& S, 
+static void parse_DIMACS(gzFile input_stream, Solver& S, Prooflogger &PL, 
 			 int& out_nbvar, int& out_top, int& out_nbsoft) { // koshi 10.01.04
     StreamBuffer in(input_stream);
-    parse_DIMACS_main(in, S, out_nbvar, out_top, out_nbsoft); }
+    parse_DIMACS_main(in, S, PL, out_nbvar, out_top, out_nbsoft); }
 
 
 //=================================================================================================
@@ -232,10 +250,13 @@
 {
     reportf("USAGE: %s [options] <input-file> <result-output-file>\n\n  where input may be either in plain or gzipped DIMACS.\n\n", argv[0]);
     reportf("OPTIONS:\n\n");
-    reportf("  -polarity-mode = {true,false,rnd}\n");
-    reportf("  -decay         = <num> [ 0 - 1 ]\n");
-    reportf("  -rnd-freq      = <num> [ 0 - 1 ]\n");
-    reportf("  -verbosity     = {0,1,2}\n");
+    reportf("  -polarity-mode       = {true,false,rnd}\n");
+    reportf("  -decay               = <num> [ 0 - 1 ]\n");
+    reportf("  -rnd-freq            = <num> [ 0 - 1 ]\n");
+    reportf("  -verbosity           = {0,1,2}\n");
+    reportf("  -proof-file          = /path/to/proof_file.proof (default: maxsat_proof.pbp)\n");
+    reportf("  -problem-file        = /path/to/problem_file.opb (default: maxsat_problem.opb)\n");
+    reportf("  -meaningful_names    = whether or not to assign meaningful names to the auxiliairy variables\n");
     reportf("\n");
 }
 
@@ -251,7 +272,7 @@
 
 // koshi 10.01.08
 void genCardinals(int from, int to, 
-		  Solver& S, vec<Lit>& lits, vec<Lit>& linkingVar) {
+		  Solver& S, Prooflogger& PL, vec<Lit>& lits, vec<Lit>& linkingVar) {
   int inputSize = to - from + 1;
   linkingVar.clear();
 
@@ -261,42 +282,54 @@
   Var varZero = S.newVar();
   Var varLast = S.newVar();
 
+  // First
   lits.clear(); lits.push(Lit(varZero)); S.addClause(lits);
+  PL.write_unit_sub_red(lits, 0, from, to);
+
+  // Last
   lits.clear(); lits.push(~Lit(varLast)); S.addClause(lits);
+  PL.write_unit_sub_red(lits, inputSize+1, from, to);
+
 
   if (inputSize > 2) {
     int middle = inputSize/2;
-    genCardinals(from, from+middle, S,lits,linkingAlpha);
-    genCardinals(from+middle+1, to, S,lits,linkingBeta);
+    genCardinals(from, from+middle, S,PL,lits,linkingAlpha);
+    genCardinals(from+middle+1, to, S,PL,lits,linkingBeta);
   } else if (inputSize == 2) {
-    genCardinals(from, from, S,lits,linkingAlpha);
-    genCardinals(to, to, S,lits,linkingBeta);
+    genCardinals(from, from, S,PL,lits,linkingAlpha);
+    genCardinals(to, to, S,PL,lits,linkingBeta);
   }
   if (inputSize == 1) {
     linkingVar.push(Lit(varZero));
     linkingVar.push(Lit(from));
     linkingVar.push(Lit(varLast));
   } else { // inputSize >= 2
+
+    PL.write_comment("- Node clauses:");
     linkingVar.push(Lit(varZero));
     for (int i = 0; i < inputSize; i++) linkingVar.push(Lit(S.newVar()));
     linkingVar.push(Lit(varLast));
+
     for (int sigma = 0; sigma <= inputSize; sigma++) {
-      for (int alpha = 0; alpha < linkingAlpha.size()-1; alpha++) {
-	int beta = sigma - alpha;
-	if (0 <= beta && beta < linkingBeta.size()-1) { // create constraints
-	  lits.clear();
-	  lits.push(~linkingAlpha[alpha]);
-	  lits.push(~linkingBeta[beta]);
-	  lits.push(linkingVar[sigma]);
-	  S.addClause(lits);
-	  lits.clear();
-	  lits.push(linkingAlpha[alpha+1]);
-	  lits.push(linkingBeta[beta+1]);
-	  lits.push(~linkingVar[sigma+1]);
-	  S.addClause(lits);
-	}
-      }
+        for (int alpha = 0; alpha < linkingAlpha.size()-1; alpha++) {
+	        int beta = sigma - alpha;
+	        if (0 <= beta && beta < linkingBeta.size()-1) { // create constraints
+	            lits.clear();
+	            lits.push(~linkingAlpha[alpha]);
+	            lits.push(~linkingBeta[beta]);
+	            lits.push(linkingVar[sigma]);
+                PL.write_C1(lits, sigma, from, to);
+	            S.addClause(lits);
+	            lits.clear();
+	            lits.push(linkingAlpha[alpha+1]);
+	            lits.push(linkingBeta[beta+1]);
+	            lits.push(~linkingVar[sigma+1]);
+                PL.write_C2(lits, sigma+1, from, to);
+	            S.addClause(lits);
+	        }
+        }
     }
+    PL.write_comment("-------------------------------------------");
   }
   linkingAlpha.clear();
   linkingBeta.clear();
@@ -304,10 +337,10 @@
 
 int main(int argc, char** argv)
 {
-    Solver      S;
+    Prooflogger PL;
+    Solver      S(&PL);
     S.verbosity = 1;
 
-
     int         i, j;
     const char* value;
     for (i = j = 0; i < argc; i++){
@@ -347,6 +380,16 @@
             printUsage(argv);
             exit(0);
 
+        } else if ((value = hasPrefix(argv[i], "-proof-file="))) {
+            PL.set_proof_name(value);
+
+        /*  // wcnf file read directly by veripb
+        } else if ((value = hasPrefix(argv[i], "-opb-file="))) {
+            PL.set_OPB_name(value);
+        */
+        }else if (strcmp(argv[i], "-mn") == 0 || strcmp(argv[i], "-meaningful_names") == 0 || strcmp(argv[i], "--meaningful_names") == 0){
+            PL.meaningful_names = true;
+
         }else if (strncmp(argv[i], "-", 1) == 0){
             reportf("ERROR! unknown flag %s\n", argv[i]);
             exit(0);
@@ -357,7 +400,7 @@
     argc = j;
 
 
-    reportf("This is QMaxSAT 0.1 based on MiniSat 2.0 beta\n");
+    reportf("This is QMaxSAT 0.1 based on MiniSat 2.0 beta, extended for prooflogging\n");
 #if defined(__linux__)
     fpu_control_t oldcw, newcw;
     _FPU_GETCW(oldcw); newcw = (oldcw & ~_FPU_EXTENDED) | _FPU_DOUBLE; _FPU_SETCW(newcw);
@@ -376,6 +419,12 @@
     if (in == NULL)
         reportf("ERROR! Could not open file: %s\n", argc == 1 ? "<stdin>" : argv[1]), exit(1);
 
+    // Open OPB file 
+    // PL.open_OPB_file(); // wcnf file read directly by veripb
+
+    // Open proof file
+    PL.open_proof_file();
+
     reportf("============================[ Problem Statistics ]=============================\n");
     reportf("|                                                                             |\n");
 
@@ -383,8 +432,18 @@
     int nbvar  = 0; // number of original variables
     int top    = 0; // weight of hard clause
     int nbsoft = 0; // number of soft clauses
-    parse_DIMACS(in, S, nbvar, top, nbsoft);
+    parse_DIMACS(in, S, PL, nbvar, top, nbsoft);
+    
+    // Initialise PL constraint counter
+    PL.constraint_counter = S.nClauses();
+
+    // Close input file
     gzclose(in);
+
+    // Write OPB constraints 
+    //PL.write_OPB_file(); // wcnf file read directly by veripb
+
+    // Open output file
     FILE* res = (argc >= 3) ? fopen(argv[2], "wb") : NULL;
 
     double parse_time = cpuTime() - cpu_time;
@@ -393,6 +452,8 @@
     if (!S.simplify()){
         reportf("Solved by unit propagation\n");
         if (res != NULL) fprintf(res, "UNSAT\n"), fclose(res);
+        PL.write_empty_clause();
+        PL.close_proof_file();
         printf("UNSATISFIABLE\n");
         exit(20);
     }
@@ -406,23 +467,41 @@
     if (ret) { // koshi 09.12.25
       lcnt++;
       int answerNew = 0;
-      for (int i = nbvar; i < nbvar+nbsoft; i++) // count the number of
-	if (S.model[i] == l_True) answerNew++;   // unsatisfied soft clauses
-      if (lcnt == 1) { // first model: generate cardinal constraints
-	genCardinals(nbvar,nbvar+nbsoft-1, S,lits,linkingVar);
-	for (int i = answerNew; i < linkingVar.size()-1; i++) {
-	  lits.clear();
-	  lits.push(~linkingVar[i]);
-	  S.addClause(lits);
-	}
-	answer = answerNew;
+      for (int i = nbvar; i < nbvar+nbsoft; i++) if (S.model[i] == l_True) answerNew++;   // count the number ofunsatisfied soft clauses
+      if (lcnt == 1) { // first model: generate cardinality constraints
+          PL.write_comment("==============================================================");
+          PL.write_comment("First model found:"); 
+          PL.write_bound_update(S.model);
+          PL.write_comment("==============================================================");
+          PL.write_comment("Cardinality encoding:"); 
+	       genCardinals(nbvar,nbvar+nbsoft-1, S,PL,lits,linkingVar);
+          PL.write_comment("==============================================================");
+          PL.write_comment("Tree derivation:"); 
+          PL.write_tree_derivation();
+          PL.write_comment("==============================================================");
+          PL.write_comment("Constraining through linking variables:"); 
+	       for (int i = answerNew; i < linkingVar.size()-1; i++) {
+	         lits.clear();
+	         lits.push(~linkingVar[i]);
+             PL.write_linkingVar_clause(lits);
+	         S.addClause(lits);
+	       }
+          PL.write_comment("==============================================================");
+          answer = answerNew;
       } else { // lcnt > 1 
-	for (int i = answerNew; i < answer; i++) {
-	  lits.clear();
-	  lits.push(~linkingVar[i]);
-	  S.addClause(lits);
-	}
-	answer = answerNew;
+          PL.write_comment("==============================================================");
+          PL.write_comment("New model found:"); 
+          PL.write_bound_update(S.model);
+          PL.write_comment("==============================================================");
+          PL.write_comment("Constraining through linking variables:"); 
+	       for (int i = answerNew; i < answer; i++) {
+	           lits.clear();
+	           lits.push(~linkingVar[i]);
+               PL.write_linkingVar_clause(lits);
+	           S.addClause(lits);
+	       }
+          PL.write_comment("==============================================================");
+          answer = answerNew;
       }
       reportf("Current answer = %d\n",answer);
       goto solve;
@@ -439,10 +518,11 @@
                 if (S.model[i] != l_Undef)
                     fprintf(res, "%s%s%d", (i==0)?"":" ", (S.model[i]==l_True)?"":"-", i+1);
             fprintf(res, " 0\n");
-        }else
+        } else
             fprintf(res, "UNSAT\n");
         fclose(res);
     }
+    PL.close_proof_file();
 
 #ifdef NDEBUG
     exit(ret ? 10 : 20);     // (faster than "return", which will invoke the destructor for 'Solver')
diff -ruN src_tmp/core/Prooflogger.C src/core/Prooflogger.C
--- src_tmp/core/Prooflogger.C	1970-01-01 01:00:00.000000000 +0100
+++ src/core/Prooflogger.C	2022-02-07 12:18:18.496585500 +0100
@@ -0,0 +1,334 @@
+#include "Prooflogger.h"
+
+//=================================================================================================
+// Prooflogger -- VeriPB operation classes:
+
+// Initialisers
+CPOperand::CPOperand(int value) : value(value){};
+RUP::RUP(vec<Lit>& in_clause) {
+    for(int i = 0; i < in_clause.size(); i++) {
+        clause.push(in_clause[i]);
+    }
+};
+CP1::CP1(VeriPBOperation* a, const char* operant) : a(a), operant(operant){};
+CP2::CP2(VeriPBOperation* a, VeriPBOperation* b, const char* operant) : a(a), b(b), operant(operant){};
+
+std::string CP1::apply(int constraint_id_at_start_of_printing) {
+    return a->apply(constraint_id_at_start_of_printing)  
+                                   + " " + this->operant;
+}
+
+std::string CP2::apply(int constraint_id_at_start_of_printing) {
+    return a->apply(constraint_id_at_start_of_printing) + " " 
+                                   + b->apply(constraint_id_at_start_of_printing) 
+                                   + " " + this->operant ;
+}
+
+std::string CPOperand::apply(int constraint_id_at_start_of_printing){
+    return std::to_string(this->value < 0 ? abs(this->value) + constraint_id_at_start_of_printing : this->value);
+}
+
+
+//=================================================================================================
+// Proof file
+
+void Prooflogger::write_tree_derivation() {
+    int constraint_counter_at_start_of_derivations = constraint_counter;
+    for(int i = 0; i < tree_derivation.size(); i++){
+
+        // Write RPN
+        if(dynamic_cast<RUP*>(tree_derivation[i]) != nullptr) {
+            RUP* learned_clause = dynamic_cast<RUP*>(tree_derivation[i]);
+            write_learnt_clause(learned_clause->clause);
+        } else {
+            proof << "p " << tree_derivation[i]->apply(constraint_counter_at_start_of_derivations ) << "\n";
+            constraint_counter++;
+        }
+
+        // Tree recursively free the tree derivation
+        delete_tree_derivation(tree_derivation[i]);
+    }
+}
+
+void Prooflogger::delete_tree_derivation(VeriPBOperation* node) {
+    if(dynamic_cast<CP1*>(node) != nullptr) {
+        delete_tree_derivation(dynamic_cast<CP1*>(node)->a);
+    } else if(dynamic_cast<CP2*>(node) != nullptr) {
+        delete_tree_derivation(dynamic_cast<CP2*>(node)->a);
+        delete_tree_derivation(dynamic_cast<CP2*>(node)->b);
+    } 
+    delete(node);
+}
+
+void Prooflogger::write_proof_header(int nbclause) {
+    proof << "pseudo-Boolean proof version 1.0\n";
+    proof << "f " << nbclause << "\n";
+}
+
+void Prooflogger::write_comment(const char* comment) {
+    proof<< "* " << comment << "\n";
+}
+
+void Prooflogger::write_contradiction() {
+    proof << "c " << constraint_counter << "\n";
+}
+
+void Prooflogger::write_empty_clause() {
+    proof<< "u >= 1;\n";
+    constraint_counter++;
+    write_contradiction();
+}
+
+bool Prooflogger::is_aux_var(int var) {
+    return var + 1 > n_variables;
+}
+
+std::string Prooflogger::var_name(int var) {
+    std::string name;
+    if(meaningful_names && meaningful_name_UB.find(var) != meaningful_name_UB.end()) {
+        int lb = meaningful_name_LB[var];
+        int ub = meaningful_name_UB[var];
+        int n = meaningful_name_n[var];
+        name = "v" + std::to_string(n) + "_x" + std::to_string(lb) + "_x" + std::to_string(ub); 
+    } else if(is_aux_var(var)) {
+        name = "y";
+        name += std::to_string(var+1);
+    } else {
+        name = "x";
+        name += std::to_string(var+1);
+    } 
+    return name;
+}
+
+void Prooflogger::write_literal(Lit literal) {
+
+    // Weight and sign
+    std::string weight_and_sign = "1 ";
+    weight_and_sign += (sign(literal) == 1 ? "~" : "");
+
+    // Variable symbol
+    std::string name = var_name(var(literal));
+
+    // Write
+    proof << weight_and_sign << name << " ";
+}
+
+void Prooflogger::write_literal_assignment(lbool assignment, int var) {
+
+    // Sign
+    std::string sign = assignment == l_True? "" : "~";
+
+    // Variable symbol
+    std::string symbol = var_name(var);
+
+    // Write
+    proof << sign << symbol << " ";
+}
+
+void Prooflogger::write_witness(Lit literal) {
+    std::string name = var_name(var(literal));
+    proof<< name << " -> " << std::to_string(sign(literal) == 0);
+}
+
+void Prooflogger::write_clause(vec<Lit>& clause) {
+    for (int i = 0; i < clause.size(); i++) write_literal(clause[i]);
+}
+
+void Prooflogger::write_learnt_clause(vec<Lit>& clause) {
+    proof << "u ";
+    write_clause(clause);
+    proof << " >= 1;\n";
+    constraint_counter++;
+}
+
+void Prooflogger::write_linkingVar_clause(vec<Lit>& clause) {
+    int variable = var(clause[0]);
+    int constraint_id = C2_store[variable];
+    if(constraint_id != 0) {
+        proof << "p " << constraint_id << " " << last_bound_constraint_id << " + s\n";
+        constraint_counter++;
+    }
+    write_learnt_clause(clause);
+}
+
+void Prooflogger::write_bound_update(vec<lbool>& model) {
+    proof<< "o ";
+    for(int i = 0; i < model.size(); i++) write_literal_assignment(model[i], i);
+    proof << "\n";
+
+    // Veripb automatically adds an improvement constraint so counter needs to be incremented
+    last_bound_constraint_id = ++constraint_counter;
+}
+
+void Prooflogger::write_unit_sub_red(vec<Lit>& definition, int sigma, int from, int to) {
+
+    if(meaningful_names) {
+
+        // If variable does not already have a meaningful name
+        if(meaningful_name_LB.find(var(definition[0])) == meaningful_name_LB.end()) {
+            meaningful_name_LB[var(definition[0])] = from+1;
+            meaningful_name_UB[var(definition[0])] = to+1;
+            meaningful_name_n[var(definition[0])] = sigma;
+        }
+    }
+
+    proof << "red ";
+    write_clause(definition);
+    proof << ">= 1; ";
+    write_witness(definition[0]);
+    proof << "\n";
+    constraint_counter++;
+}
+
+void Prooflogger::write_P1_sub_red_cardinality(int var, int sigma, int from, int to) {
+    int weight = (to-from+1)-(sigma - 1);
+    proof << "red ";
+    for(int i = from; i < to+1; i++) {
+        write_literal(~Lit(i));
+    }
+    proof << weight << " " << var_name(var) << " >= " << weight << "; ";
+    write_witness(Lit(var));
+    proof << "\n";
+    constraint_counter++;
+    C1_store[var] = constraint_counter;
+    C1_weight_store[var] = weight;
+}
+
+void Prooflogger::write_P2_sub_red_cardinality(int var, int sigma, int from, int to) {
+    int weight = sigma;
+    proof << "red ";
+    for(int i = from; i < to+1; i++) {
+        write_literal(Lit(i));
+    }
+    proof << weight << " ~" << var_name(var) << " >= " << weight << "; ";
+    write_witness(~Lit(var));
+    proof << "\n";
+    constraint_counter++;
+    C2_store[var] = constraint_counter;
+    C2_weight_store[var] = weight;
+}
+
+void Prooflogger::write_C1(vec<Lit>& definition, int sigma, int from, int to) {
+    int first = var(definition[0]);
+    int second = var(definition[1]);
+    int third = var(definition[2]);
+
+    if(meaningful_names) {
+
+        // If variable does not already have a meaningful name
+        if(meaningful_name_LB.find(third) == meaningful_name_LB.end()) {
+            meaningful_name_LB[third] = from+1;
+            meaningful_name_UB[third] = to+1;
+            meaningful_name_n[third] = sigma;
+        }
+    }
+
+    // Verify if PB cardinality definition exists
+    if(C1_store.find(third) == C1_store.end()) {
+
+        // Write a substitution redundancy PB cardinality definition
+        write_P1_sub_red_cardinality(third, sigma, from, to);
+    }
+
+    // Write derivation of parts
+    int total_weight = C1_weight_store[third];
+    bool resolved_one = false;
+    if(C2_store.find(first) != C2_store.end()) {
+        resolved_one = true;
+        tree_derivation.push(new CP2(new CPOperand(C1_store[third]), new CPOperand(C2_store[first]), "+"));
+        tree_constraint_counter++;
+        total_weight += C2_weight_store[first];
+    }
+    if(C2_store.find(second) != C2_store.end()) {
+        int to_add_to = resolved_one? -tree_constraint_counter : C1_store[third];
+        resolved_one = true;
+        tree_derivation.push(new CP2(new CPOperand(to_add_to), new CPOperand(C2_store[second]), "+"));
+        tree_constraint_counter++;
+        total_weight += C2_weight_store[second];
+    }
+    if(resolved_one) {
+        tree_derivation.push(new CP1(new CPOperand(-tree_constraint_counter), "s"));
+        tree_constraint_counter++;
+    }
+
+    // Derivation is done so clause can be written as RUP
+    tree_derivation.push(new RUP(definition));
+    tree_constraint_counter++;
+}
+
+void Prooflogger::write_C2(vec<Lit>& definition, int sigma, int from, int to) {
+    int first = var(definition[0]);
+    int second = var(definition[1]);
+    int third = var(definition[2]);
+
+    if(meaningful_names) {
+
+        // If variable does not already have a meaningful name
+        if(meaningful_name_LB.find(third) == meaningful_name_LB.end()) {
+            meaningful_name_LB[third] = from+1;
+            meaningful_name_UB[third] = to+1;
+            meaningful_name_n[third] = sigma;
+        }
+    }
+
+    // Verify if PB cardinality definition exists
+    if(C2_store.find(third) == C2_store.end()) {
+
+        // Write a substitution redundancy PB cardinality definition
+        write_P2_sub_red_cardinality(third, sigma, from, to);
+    }
+
+    // Write derivation of parts
+    int total_weight = C2_weight_store[third];
+    bool resolved_one = false;
+    if(C1_store.find(first) != C1_store.end()) {
+        resolved_one = true;
+        tree_derivation.push(new CP2(new CPOperand(C2_store[third]), new CPOperand(C1_store[first]), "+"));
+        tree_constraint_counter++;
+        total_weight += C1_weight_store[first];
+    }
+    if(C1_store.find(second) != C1_store.end()) {
+        int to_add_to = resolved_one? -tree_constraint_counter : C2_store[third];
+        resolved_one = true;
+        tree_derivation.push(new CP2(new CPOperand(to_add_to), new CPOperand(C1_store[second]), "+"));
+        tree_constraint_counter++;
+        total_weight += C1_weight_store[second];
+    }
+    if(resolved_one) {
+        tree_derivation.push(new CP1(new CP2(new CPOperand(-tree_constraint_counter), new CPOperand(2), "d"), "s"));
+        tree_constraint_counter++;
+    }
+
+    // Derivation is done so clause can be written as RUP
+    tree_derivation.push(new RUP(definition));
+    tree_constraint_counter++;
+}
+
+
+//=================================================================================================
+// OPB file
+
+void Prooflogger::write_OPB_header(int nbvar, int nbsoft, int nbclause) {
+    OPB_file << "* #variable= " << nbvar+nbsoft << " #constraint= " << nbclause << "\n";
+    OPB_file << "*\n* This MaxSAT instance was automatically generated.\n*\n";
+}
+
+void Prooflogger::write_minimise(int start_var, int num) {
+    if(num > 0) {
+        OPB_file << "min: ";
+        for(int i = start_var+1; i < start_var+num+1; i++) {
+            OPB_file << "1 x" << i << " ";
+        } 
+        OPB_file << ";\n";
+    }
+}
+
+void Prooflogger::write_OPB_constraint(vec<Lit>& constraint) {
+    for (int i = 0; i < constraint.size(); i++) {
+        if (sign(constraint[i]) == 1)
+            constraints << "1 ~x" << var(constraint[i]) + 1 << " ";
+        else
+            constraints << "1 x" << var(constraint[i]) + 1 << " ";
+    }
+    constraints << ">= 1;\n";
+}
\ No newline at end of file
diff -ruN src_tmp/core/Prooflogger.h src/core/Prooflogger.h
--- src_tmp/core/Prooflogger.h	1970-01-01 01:00:00.000000000 +0100
+++ src/core/Prooflogger.h	2022-01-04 17:16:50.736056400 +0100
@@ -0,0 +1,157 @@
+#ifndef Prooflogger_h
+#define Prooflogger_h
+
+#include <cstdio>
+#include <fstream>
+#include <iostream>
+#include <sstream>
+#include <map>
+#include <string>
+#include <regex>
+
+#include "Vec.h"
+#include "Heap.h"
+#include "Alg.h"
+
+#include "SolverTypes.h"
+
+//=================================================================================================
+// Prooflogger -- VeriPB operation classes:
+
+class VeriPBOperation {
+public:
+    virtual std::string apply(int constraint_id_at_start_of_printing){};
+};
+
+class CPOperand : public VeriPBOperation {
+public:
+    CPOperand(int value);
+
+    // Value
+    //
+    int value;
+
+    std::string apply(int constraint_id_at_start_of_printing) override;
+};
+
+class RUP : public VeriPBOperation {
+public:
+    RUP(vec<Lit>& clause);
+
+    // Clause
+    //
+    vec<Lit> clause;
+};
+
+class CP1 : public VeriPBOperation {
+public:
+    CP1(VeriPBOperation* a, const char* operant);
+
+    // Operands
+    //
+    VeriPBOperation* a;
+
+    // Operant
+    //
+    std::string operant;
+
+    // Apply
+    //
+    std::string apply(int constraint_id_at_start_of_printing) override;
+};
+
+class CP2 : public VeriPBOperation {
+public:
+    CP2(VeriPBOperation* a, VeriPBOperation* b, const char* operant);
+
+    // Operands
+    //
+    VeriPBOperation* a;
+    VeriPBOperation* b;
+
+    // Operant
+    //
+    std::string operant;
+
+    // Apply
+    //
+    std::string apply(int constraint_id_at_start_of_printing) override;
+};
+
+//=================================================================================================
+// Prooflogger -- the main class:
+
+
+class Prooflogger {
+public:
+
+    // Formula information
+    //
+    int formula_length = 0;
+    int n_variables = 0;
+
+    // Constraint counter
+    //
+    int constraint_counter = 0;
+    int last_bound_constraint_id;
+
+    // Tree derivation
+    //
+    int tree_constraint_counter = 0;
+    vec<VeriPBOperation*> tree_derivation;
+
+    // Meaningful variable names
+    bool meaningful_names = false;
+    std::map<int, int> meaningful_name_LB;
+    std::map<int, int> meaningful_name_UB;
+    std::map<int, int> meaningful_name_n;
+
+    // Constraint and weight stores
+    //
+    std::map<int, int> C1_store;
+    std::map<int, int> C1_weight_store;
+    std::map<int, int> C2_store;
+    std::map<int, int> C2_weight_store;
+
+    // Proof file
+    std::ofstream proof;
+    const char *proof_file_name         = "maxsat_proof.pbp";
+    void set_proof_name                 (const char* name) {proof_file_name = name;};
+    void open_proof_file                (){proof.open(proof_file_name);};
+    void close_proof_file               (){proof.close();};
+    void write_tree_derivation          ();
+    void delete_tree_derivation         (VeriPBOperation* node); 
+    void write_proof_header             (int nbclause);
+    void write_comment                  (const char* comment);
+    void write_contradiction            ();
+    void write_empty_clause             ();
+    bool is_aux_var                     (int var); 
+    std::string var_name                (int var); 
+    void write_literal                  (Lit literal);
+    void write_literal_assignment       (lbool assignment, int var);
+    void write_witness                  (Lit literal);
+    void write_clause                   (vec<Lit>& clause);
+    void write_learnt_clause            (vec<Lit>& clause);
+    void write_linkingVar_clause        (vec<Lit>& clause);
+    void write_bound_update             (vec<lbool>& model); 
+    void write_unit_sub_red             (vec<Lit>& definition, int sigma, int from, int to);
+    void write_C1                       (vec<Lit>& definition, int sigma, int from, int to);
+    void write_P1_sub_red_cardinality   (int var, int sigma, int from, int to);
+    void write_C2                       (vec<Lit>& definition, int sigma, int from, int to);
+    void write_P2_sub_red_cardinality   (int var, int sigma, int from, int to);
+
+    // OPB file
+    std::ofstream OPB_file;
+    std::stringstream constraints;
+    const char *OPB_file_name           = "maxsat_problem.opb";
+    void open_OPB_file                  ()                   {OPB_file.open(OPB_file_name);};
+    void write_OPB_file                 ()                   {OPB_file << constraints.rdbuf(); OPB_file.close();};
+    void set_OPB_name                   (const char* name)   {OPB_file_name = name;};
+
+    void write_OPB_header               (int nbvar, int nbsoft, int nbclause);
+    void write_minimise                 (int start_var, int num);
+    void write_OPB_constraint           (vec<Lit>& constraint);
+};
+
+//=================================================================================================
+#endif
\ No newline at end of file
diff -ruN src_tmp/core/Solver.C src/core/Solver.C
--- src_tmp/core/Solver.C	2022-02-07 14:54:10.164822800 +0100
+++ src/core/Solver.C	2021-12-26 11:37:17.936500100 +0100
@@ -26,7 +26,7 @@
 // Constructor/Destructor:
 
 
-Solver::Solver() :
+Solver::Solver(Prooflogger *PL) :
 
     // Parameters: (formerly in 'SearchParams')
     var_decay(1 / 0.95), clause_decay(1 / 0.999), random_var_freq(0.02)
@@ -53,6 +53,10 @@
   , random_seed      (91648253)
   , progress_estimate(0)
   , remove_satisfied (true)
+
+  // Prooflogger
+  //
+  , PL(PL)
 {}
 
 
@@ -544,7 +548,7 @@
 |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
 |    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
 |________________________________________________________________________________________________@*/
-lbool Solver::search(int nof_conflicts, int nof_learnts)
+lbool Solver::search(int nof_conflicts, int nof_learnts) 
 {
     assert(ok);
     int         backtrack_level;
@@ -560,12 +564,19 @@
         if (confl != NULL){
             // CONFLICT
             conflicts++; conflictC++;
-            if (decisionLevel() == 0) return l_False;
+            if (decisionLevel() == 0) {
+                PL->write_empty_clause();
+                return l_False;
+            }
 
             first = false;
 
             learnt_clause.clear();
             analyze(confl, learnt_clause, backtrack_level);
+
+            // Write the learnt clause to the proof file
+            PL->write_learnt_clause(learnt_clause);
+
             cancelUntil(backtrack_level);
             assert(value(learnt_clause[0]) == l_Undef);
 
@@ -592,8 +603,10 @@
                 return l_Undef; }
 
             // Simplify the set of problem clauses:
-            if (decisionLevel() == 0 && !simplify())
+            if (decisionLevel() == 0 && !simplify()) {
+                PL->write_empty_clause();
                 return l_False;
+            }
 
             if (nof_learnts >= 0 && learnts.size()-nAssigns() >= nof_learnts)
                 // Reduce the set of learnt clauses:
@@ -654,7 +667,10 @@
     model.clear();
     conflict.clear();
 
-    if (!ok) return false;
+    if (!ok) {
+        PL->write_empty_clause();
+        return false;
+    }
 
     assumps.copyTo(assumptions);
 
diff -ruN src_tmp/core/Solver.h src/core/Solver.h
--- src_tmp/core/Solver.h	2022-02-07 14:54:10.163953800 +0100
+++ src/core/Solver.h	2021-12-22 10:25:15.730665200 +0100
@@ -21,12 +21,15 @@
 #define Solver_h
 
 #include <cstdio>
+#include <fstream>
+#include <iostream>
 
 #include "Vec.h"
 #include "Heap.h"
 #include "Alg.h"
 
 #include "SolverTypes.h"
+#include "Prooflogger.h"
 
 
 //=================================================================================================
@@ -38,9 +41,13 @@
 
     // Constructor/Destructor:
     //
-    Solver();
+    Solver(Prooflogger *PL);
     ~Solver();
 
+    // Proof logging:
+    //
+    Prooflogger* PL;
+
     // Problem specification:
     //
     Var     newVar    (bool polarity = true, bool dvar = true); // Add a new variable with parameters specifying variable mode.
@@ -146,19 +153,19 @@
 
     // Main internal methods:
     //
-    void     insertVarOrder   (Var x);                                                 // Insert a variable in the decision order priority queue.
-    Lit      pickBranchLit    (int polarity_mode, double random_var_freq);             // Return the next decision variable.
-    void     newDecisionLevel ();                                                      // Begins a new decision level.
-    void     uncheckedEnqueue (Lit p, Clause* from = NULL);                            // Enqueue a literal. Assumes value of literal is undefined.
-    bool     enqueue          (Lit p, Clause* from = NULL);                            // Test if fact 'p' contradicts current state, enqueue otherwise.
-    Clause*  propagate        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
-    void     cancelUntil      (int level);                                             // Backtrack until a certain level.
-    void     analyze          (Clause* confl, vec<Lit>& out_learnt, int& out_btlevel); // (bt = backtrack)
-    void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
-    bool     litRedundant     (Lit p, uint32_t abstract_levels);                       // (helper method for 'analyze()')
-    lbool    search           (int nof_conflicts, int nof_learnts);                    // Search for a given number of conflicts.
-    void     reduceDB         ();                                                      // Reduce the set of learnt clauses.
-    void     removeSatisfied  (vec<Clause*>& cs);                                      // Shrink 'cs' to contain only non-satisfied clauses.
+    void     insertVarOrder   (Var x);                                                  // Insert a variable in the decision order priority queue.
+    Lit      pickBranchLit    (int polarity_mode, double random_var_freq);              // Return the next decision variable.
+    void     newDecisionLevel ();                                                       // Begins a new decision level.
+    void     uncheckedEnqueue (Lit p, Clause* from = NULL);                             // Enqueue a literal. Assumes value of literal is undefined.
+    bool     enqueue          (Lit p, Clause* from = NULL);                             // Test if fact 'p' contradicts current state, enqueue otherwise.
+    Clause*  propagate        ();                                                       // Perform unit propagation. Returns possibly conflicting clause.
+    void     cancelUntil      (int level);                                              // Backtrack until a certain level.
+    void     analyze          (Clause* confl, vec<Lit>& out_learnt, int& out_btlevel);  // (bt = backtrack)
+    void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                          // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
+    bool     litRedundant     (Lit p, uint32_t abstract_levels);                        // (helper method for 'analyze()')
+    lbool    search           (int nof_conflicts, int nof_learnts);                     // Search for a given number of conflicts.
+    void     reduceDB         ();                                                       // Reduce the set of learnt clauses.
+    void     removeSatisfied  (vec<Clause*>& cs);                                       // Shrink 'cs' to contain only non-satisfied clauses.
 
     // Maintaining Variable/Clause activity:
     //
