diff -ruN src_tmp/core/Main.C src/core/Main.C
--- src_tmp/core/Main.C	2021-12-26 20:06:51.200749500 +0100
+++ src/core/Main.C	2021-12-26 16:43:32.985062100 +0100
@@ -27,6 +27,7 @@
 #include <zlib.h>
 
 #include "Solver.h"
+#include "Prooflogger.h"
 
 /*************************************************************************************/
 #ifdef _MSC_VER
@@ -131,18 +132,18 @@
     return neg ? -val : val; }
 
 template<class B>
-static void readClause(B& in, Solver& S, vec<Lit>& lits, 
+static void readClause(B& in, Solver& S, Prooflogger& PL, vec<Lit>& lits, 
 		       int nbvar, int top, int& nbsoft) { // koshi 10.01.04
 
-    int     parsed_lit, var;
+    int parsed_lit, var, weight;
     lits.clear();
-    parsed_lit = parseInt(in); // koshi 10.01.04
-    if (parsed_lit == 1) { // soft clause
+    weight = parseInt(in); // koshi 10.01.04
+    if (weight == 1) { // soft clause
       nbsoft++;
       lits.push(Lit(S.newVar()));
-    } else if (parsed_lit != top) { // weight of hard clause must be top
+    } else if (weight != top) { // weight of hard clause must be top
       reportf("Unexpected weight %c\n", *in), exit(3);
-    }
+    } else weight = top;
 
     for (;;){
         parsed_lit = parseInt(in);
@@ -151,6 +152,9 @@
 	// koshi 10.01.04        while (var >= S.nVars()) S.newVar();
         lits.push( (parsed_lit > 0) ? Lit(var) : ~Lit(var) );
     }
+
+    // Write the clause to the OPB file
+    PL.write_OPB_constraint(lits, weight);
 }
 
 template<class B>
@@ -163,42 +167,52 @@
 
 
 template<class B>
-static void parse_DIMACS_main(B& in, Solver& S, 
+static void parse_DIMACS_main(B& in, Solver& S, Prooflogger &PL, 
 			      int& out_nbvar, int& out_top, int& out_nbsoft) {
     vec<Lit> lits;
+    int vars, clauses;
+
+    // Read header
+    skipWhitespace(in);
+    if (*in == 'p'){
+	     if (match(in, "p wcnf")){ // koshi 10.01.04
+            vars    = parseInt(in);
+            clauses = parseInt(in);
+		    int top     = parseInt(in);
+		    out_nbvar   = vars;
+		    out_top     = top;
+            reportf("|  Number of variables:    %-12d                                       |\n", vars);
+            reportf("|  Number of clauses:      %-12d                                       |\n", clauses);
+            reportf("|  Weight of hard clauses: %-12d                                       |\n", top);
+		    while (vars > S.nVars()) S.newVar();
+        } else {
+            reportf("PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
+        }
+    } else reportf("PARSE ERROR! No header given!");
+
+    // Read clauses
     for (;;){
         skipWhitespace(in);
         if (*in == EOF)
             break;
-        else if (*in == 'p'){
-	  if (match(in, "p wcnf")){ // koshi 10.01.04
-                int vars    = parseInt(in);
-                int clauses = parseInt(in);
-		int top     = parseInt(in);
-		out_nbvar   = vars;
-		out_top     = top;
-                reportf("|  Number of variables:    %-12d                                       |\n", vars);
-                reportf("|  Number of clauses:      %-12d                                       |\n", clauses);
-                reportf("|  Weight of hard clauses: %-12d                                       |\n", top);
-		while (vars > S.nVars()) S.newVar();
-            }else{
-                reportf("PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
-            }
-        } else if (*in == 'c' || *in == 'p')
-            skipLine(in);
-        else
-	  readClause(in, S, lits, out_nbvar,out_top,out_nbsoft),
+        else if (*in == 'c' || *in == 'p') skipLine(in);
+        else {
+	        readClause(in, S, PL, lits, out_nbvar,out_top,out_nbsoft),
             S.addClause(lits);
+        }
     }
     reportf("|  Number of soft clauses: %-12d                                       |\n", out_nbsoft);
+    PL.write_proof_header(clauses);
+    PL.write_OPB_header(vars, clauses);
+    PL.write_minimise(out_nbvar, out_nbsoft);
 }
 
 // Inserts problem into solver.
 //
-static void parse_DIMACS(gzFile input_stream, Solver& S, 
+static void parse_DIMACS(gzFile input_stream, Solver& S, Prooflogger &PL, 
 			 int& out_nbvar, int& out_top, int& out_nbsoft) { // koshi 10.01.04
     StreamBuffer in(input_stream);
-    parse_DIMACS_main(in, S, out_nbvar, out_top, out_nbsoft); }
+    parse_DIMACS_main(in, S, PL, out_nbvar, out_top, out_nbsoft); }
 
 
 //=================================================================================================
@@ -236,6 +250,7 @@
     reportf("  -decay         = <num> [ 0 - 1 ]\n");
     reportf("  -rnd-freq      = <num> [ 0 - 1 ]\n");
     reportf("  -verbosity     = {0,1,2}\n");
+    reportf("  -proof-file    = /path/to/proof_file.proof (default: maxsat_proof.proof)");
     reportf("\n");
 }
 
@@ -249,9 +264,11 @@
         return NULL;
 }
 
+
+
 // koshi 10.01.08
 void genCardinals(int from, int to, 
-		  Solver& S, vec<Lit>& lits, vec<Lit>& linkingVar) {
+		  Solver& S, Prooflogger& PL, vec<Lit>& lits, vec<Lit>& linkingVar) {
   int inputSize = to - from + 1;
   linkingVar.clear();
 
@@ -261,42 +278,64 @@
   Var varZero = S.newVar();
   Var varLast = S.newVar();
 
+  // First
   lits.clear(); lits.push(Lit(varZero)); S.addClause(lits);
+  PL.write_unit_sub_red(lits);
+
+  // Last
   lits.clear(); lits.push(~Lit(varLast)); S.addClause(lits);
+  PL.write_unit_sub_red(lits);
+
 
   if (inputSize > 2) {
     int middle = inputSize/2;
-    genCardinals(from, from+middle, S,lits,linkingAlpha);
-    genCardinals(from+middle+1, to, S,lits,linkingBeta);
+    genCardinals(from, from+middle, S,PL,lits,linkingAlpha);
+    genCardinals(from+middle+1, to, S,PL,lits,linkingBeta);
   } else if (inputSize == 2) {
-    genCardinals(from, from, S,lits,linkingAlpha);
-    genCardinals(to, to, S,lits,linkingBeta);
+    genCardinals(from, from, S,PL,lits,linkingAlpha);
+    genCardinals(to, to, S,PL,lits,linkingBeta);
   }
   if (inputSize == 1) {
     linkingVar.push(Lit(varZero));
     linkingVar.push(Lit(from));
     linkingVar.push(Lit(varLast));
   } else { // inputSize >= 2
+
+    // Keeping track of constraint ids for C2's
+    vec<int> constraint_ids; 
+    int constraint_id;
+    int third_var;
+
+    PL.write_comment("- Node clauses:");
     linkingVar.push(Lit(varZero));
     for (int i = 0; i < inputSize; i++) linkingVar.push(Lit(S.newVar()));
     linkingVar.push(Lit(varLast));
+
     for (int sigma = 0; sigma <= inputSize; sigma++) {
-      for (int alpha = 0; alpha < linkingAlpha.size()-1; alpha++) {
-	int beta = sigma - alpha;
-	if (0 <= beta && beta < linkingBeta.size()-1) { // create constraints
-	  lits.clear();
-	  lits.push(~linkingAlpha[alpha]);
-	  lits.push(~linkingBeta[beta]);
-	  lits.push(linkingVar[sigma]);
-	  S.addClause(lits);
-	  lits.clear();
-	  lits.push(linkingAlpha[alpha+1]);
-	  lits.push(linkingBeta[beta+1]);
-	  lits.push(~linkingVar[sigma+1]);
-	  S.addClause(lits);
-	}
-      }
+        for (int alpha = 0; alpha < linkingAlpha.size()-1; alpha++) {
+	        int beta = sigma - alpha;
+	        if (0 <= beta && beta < linkingBeta.size()-1) { // create constraints
+	            lits.clear();
+	            lits.push(~linkingAlpha[alpha]);
+	            lits.push(~linkingBeta[beta]);
+	            lits.push(linkingVar[sigma]);
+                PL.write_C_sub_red(lits, sigma, from, to);
+	            S.addClause(lits);
+	            lits.clear();
+	            lits.push(linkingAlpha[alpha+1]);
+	            lits.push(linkingBeta[beta+1]);
+	            lits.push(~linkingVar[sigma+1]);
+                constraint_id = PL.write_C_sub_red(lits, sigma+1, from, to);
+                constraint_ids.push(constraint_id);
+                third_var = var(lits[2]);
+	            S.addClause(lits);
+	        }
+        }
+        // Write sum of all C2's for certain vX_xFROM_xTO
+        PL.write_C2_sum(constraint_ids, third_var, from, to);
+        constraint_ids.clear();
     }
+    PL.write_comment("-------------------------------------------");
   }
   linkingAlpha.clear();
   linkingBeta.clear();
@@ -304,10 +343,10 @@
 
 int main(int argc, char** argv)
 {
-    Solver      S;
+    Prooflogger PL;
+    Solver      S(&PL);
     S.verbosity = 1;
 
-
     int         i, j;
     const char* value;
     for (i = j = 0; i < argc; i++){
@@ -347,6 +386,18 @@
             printUsage(argv);
             exit(0);
 
+        } else if ((value = hasPrefix(argv[i], "-proof-file="))) {
+            PL.set_proof_name(value);
+
+        } else if ((value = hasPrefix(argv[i], "-opb-file="))) {
+            PL.set_OPB_name(value);
+
+        }else if (strcmp(argv[i], "-mn") == 0 || strcmp(argv[i], "-meaningful_names") == 0 || strcmp(argv[i], "--meaningful_names") == 0){
+            PL.meaningful_names = true;
+
+        }else if (strcmp(argv[i], "-s") == 0 || strcmp(argv[i], "-simplify") == 0 || strcmp(argv[i], "--simplify") == 0){
+            PL.simplify = true;
+
         }else if (strncmp(argv[i], "-", 1) == 0){
             reportf("ERROR! unknown flag %s\n", argv[i]);
             exit(0);
@@ -357,7 +408,7 @@
     argc = j;
 
 
-    reportf("This is QMaxSAT 0.1 based on MiniSat 2.0 beta\n");
+    reportf("This is QMaxSAT 0.1 based on MiniSat 2.0 beta, extended for prooflogging\n");
 #if defined(__linux__)
     fpu_control_t oldcw, newcw;
     _FPU_GETCW(oldcw); newcw = (oldcw & ~_FPU_EXTENDED) | _FPU_DOUBLE; _FPU_SETCW(newcw);
@@ -376,6 +427,9 @@
     if (in == NULL)
         reportf("ERROR! Could not open file: %s\n", argc == 1 ? "<stdin>" : argv[1]), exit(1);
 
+    // Open OPB file
+    PL.open_OPB();
+
     reportf("============================[ Problem Statistics ]=============================\n");
     reportf("|                                                                             |\n");
 
@@ -383,8 +437,18 @@
     int nbvar  = 0; // number of original variables
     int top    = 0; // weight of hard clause
     int nbsoft = 0; // number of soft clauses
-    parse_DIMACS(in, S, nbvar, top, nbsoft);
+    parse_DIMACS(in, S, PL, nbvar, top, nbsoft);
+    
+    // Initialise PL constraint counter
+    PL.constraint_counter = S.nClauses();
+
+    // Close input file
     gzclose(in);
+
+    // Close written OPB file
+    PL.close_OPB();
+
+    // Open output file
     FILE* res = (argc >= 3) ? fopen(argv[2], "wb") : NULL;
 
     double parse_time = cpuTime() - cpu_time;
@@ -393,6 +457,8 @@
     if (!S.simplify()){
         reportf("Solved by unit propagation\n");
         if (res != NULL) fprintf(res, "UNSAT\n"), fclose(res);
+        PL.write_empty_clause();
+        PL.write_proof_file();
         printf("UNSATISFIABLE\n");
         exit(20);
     }
@@ -407,21 +473,41 @@
       lcnt++;
       int answerNew = 0;
       for (int i = nbvar; i < nbvar+nbsoft; i++) // count the number of
-	if (S.model[i] == l_True) answerNew++;   // unsatisfied soft clauses
-      if (lcnt == 1) { // first model: generate cardinal constraints
-	genCardinals(nbvar,nbvar+nbsoft-1, S,lits,linkingVar);
-	for (int i = answerNew; i < linkingVar.size()-1; i++) {
-	  lits.clear();
-	  lits.push(~linkingVar[i]);
-	  S.addClause(lits);
-	}
-	answer = answerNew;
-      } else { // lcnt > 1 
-	for (int i = answerNew; i < answer; i++) {
-	  lits.clear();
-	  lits.push(~linkingVar[i]);
-	  S.addClause(lits);
-	}
+	    if (S.model[i] == l_True) answerNew++;   // unsatisfied soft clauses
+      if (lcnt == 1) { // first model: generate cardinality constraints
+        PL.write_comment("==============================================================");
+        PL.write_comment("First model found:"); 
+        PL.write_bound_update(S.model);
+        PL.write_comment("==============================================================");
+        PL.write_comment("Cardinality encoding:"); 
+	    genCardinals(nbvar,nbvar+nbsoft-1, S,PL,lits,linkingVar);
+        PL.write_comment("==============================================================");
+        PL.write_comment("Tree derivation:"); 
+        PL.write_tree_derivation();
+        PL.write_comment("==============================================================");
+        PL.write_comment("Constraining through linking variables:"); 
+	    for (int i = answerNew; i < linkingVar.size()-1; i++) {
+	      lits.clear();
+	      lits.push(~linkingVar[i]);
+          PL.write_linkingVar_clause(lits);
+	      S.addClause(lits);
+	    }
+        PL.write_comment("==============================================================");
+        answer = answerNew;
+    } else { // lcnt > 1 
+        PL.write_comment("==============================================================");
+        PL.write_comment("New model found:"); 
+        PL.write_bound_update(S.model);
+        PL.write_comment("==============================================================");
+        PL.write_comment("Constraining through linking variables:"); 
+	    for (int i = answerNew; i < answer; i++) {
+	      lits.clear();
+	      lits.push(~linkingVar[i]);
+          PL.write_linkingVar_clause(lits);
+	      S.addClause(lits);
+	    }
+        PL.write_comment("==============================================================");
+
 	answer = answerNew;
       }
       reportf("Current answer = %d\n",answer);
@@ -439,10 +525,11 @@
                 if (S.model[i] != l_Undef)
                     fprintf(res, "%s%s%d", (i==0)?"":" ", (S.model[i]==l_True)?"":"-", i+1);
             fprintf(res, " 0\n");
-        }else
+        } else
             fprintf(res, "UNSAT\n");
         fclose(res);
     }
+    PL.write_proof_file();
 
 #ifdef NDEBUG
     exit(ret ? 10 : 20);     // (faster than "return", which will invoke the destructor for 'Solver')
diff -ruN src_tmp/core/Prooflogger.C src/core/Prooflogger.C
--- src_tmp/core/Prooflogger.C	1970-01-01 01:00:00.000000000 +0100
+++ src/core/Prooflogger.C	2021-12-26 20:06:43.760093500 +0100
@@ -0,0 +1,324 @@
+#include "Prooflogger.h"
+
+//=================================================================================================
+// Expression initialisers:
+
+Single::Single(int constraint_id) : constraint_id(constraint_id){};
+Operation::Operation(Expression* a, Expression* b, const char* operant) : a(a), b(b), operant(operant){};
+
+//=================================================================================================
+// Proof file
+
+void Prooflogger::write_proof_file() {
+
+    if(meaningful_names) {
+
+        // Loop over all variables that have a meaningful name
+        std::string proof_string;
+        std::string simplified_name;
+        std::string to_replace;
+        int lb,ub,n;
+        for(std::map<int,int>::iterator it = meaningful_name_LB.begin(); it != meaningful_name_LB.end(); it++) {
+            proof_string = proof.str();
+
+            lb = meaningful_name_LB[it->first];
+            ub = meaningful_name_UB[it->first];
+            n = meaningful_name_n[it->first];
+
+            simplified_name = "v" + std::to_string(n) + "_x" + std::to_string(lb) + "_x" + std::to_string(ub); 
+            to_replace = "y" + std::to_string(it->first+1); 
+
+            // Replace them with their meaningful name
+            proof_string = std::regex_replace(proof_string, std::regex(to_replace), simplified_name);
+
+            // Save as proof
+            proof.str(proof_string);
+        }
+    }
+
+    // Write proof to proof file
+    std::ofstream proof_file(proof_file_name);
+    proof_file << proof.rdbuf();
+
+    // Close
+    proof_file.close();
+}
+
+void Prooflogger::write_tree_derivation() {
+    // Loop over tree_derivation expressions
+    // tree_derivation.apply();
+    int constraint_counter_at_start_of_derivations = constraint_counter;
+    for(int i = 0; i < tree_derivation.size(); i++){
+        proof << "p " << tree_derivation[i]->apply(constraint_counter_at_start_of_derivations ) << "\n";
+        constraint_counter++;
+    }
+
+    std::map<int, int>::iterator it = constraint_store.begin();
+
+    while(it != constraint_store.end()){
+        int var = it->first;
+        int constraint_id = it->second;
+
+        if(constraint_id < 0){
+            constraint_store[var] = abs(constraint_id) + constraint_counter_at_start_of_derivations;
+        }
+        it++;
+    }
+}
+
+void Prooflogger::write_proof_header(int nbclause) {
+    proof << "pseudo-Boolean proof version 1.0\n";
+    proof << "f " << nbclause << "\n";
+}
+
+void Prooflogger::write_comment(const char* comment) {
+    proof<< "* " << comment << "\n";
+}
+
+void Prooflogger::write_contradiction() {
+    proof << "c " << constraint_counter << "\n";
+}
+
+void Prooflogger::write_empty_clause() {
+    proof<< "u >= 1;\n";
+    constraint_counter++;
+    write_contradiction();
+}
+
+bool Prooflogger::is_aux_var(int var) {
+    return var + 1 > formula_length + n_variables;
+}
+
+void Prooflogger::write_literal(Lit literal) {
+
+    // Weight and sign
+    std::string weight_and_sign = "1 ";
+    weight_and_sign += (sign(literal) == 1 ? "~" : "");
+
+    // Variable symbol
+    std::string symbol = is_aux_var(var(literal))? "y" : "x"; 
+    symbol += std::to_string(var(literal)+1);
+
+    // Write
+    proof << weight_and_sign << symbol << " ";
+}
+
+void Prooflogger::write_literal_assignment(lbool assignment, int var) {
+
+    // Sign
+    std::string sign = assignment == l_False ? "~" : "";
+
+    // Variable symbol
+    std::string symbol = "x";
+    symbol += std::to_string(var+1);
+
+    // Write
+    proof << sign << symbol << " ";
+}
+
+void Prooflogger::write_witness(Lit literal) {
+    proof<< " y" << var(literal)+1 << " -> " << std::to_string(sign(literal) == 0);
+}
+
+void Prooflogger::write_clause(vec<Lit>& clause) {
+    for (int i = 0; i < clause.size(); i++) write_literal(clause[i]);
+}
+
+void Prooflogger::write_learnt_clause(vec<Lit>& clause) {
+    proof << "u ";
+    write_clause(clause);
+    proof << " >= 1;\n";
+    constraint_counter++;
+}
+
+void Prooflogger::write_linkingVar_clause(vec<Lit>& clause) {
+    int variable = var(clause[0]);
+    int constraint_id = constraint_store[variable];
+    int coeff = coeff_store.find(constraint_id) != coeff_store.end() ? coeff_store[constraint_id] : 1;
+    proof << "p " << constraint_id << " " << coeff - 1 << " d " << last_bound_constraint_id << " +\n";
+    constraint_counter++;
+    write_learnt_clause(clause);
+}
+
+void Prooflogger::write_bound_update(vec<lbool>& model) {
+    proof<< "o ";
+    for(int i = 0; i < model.size(); i++) write_literal_assignment(model[i], i);
+    proof << "\n";
+
+    // Veripb automatically adds an improvement constraint so counter needs to be incremented
+    last_bound_constraint_id = ++constraint_counter;
+}
+
+void Prooflogger::write_unit_sub_red(vec<Lit>& definition) {
+    if(simplify) {
+        unit_store[var(definition[0])] = sign(definition[0]);
+        return;
+    } else {
+        proof << "red ";
+        write_clause(definition);
+        proof << " >= 1;";
+        write_witness(definition[0]);
+        proof << "\n";
+        constraint_counter++;
+    }
+}
+
+void Prooflogger::write_C2_sum(vec<int>& constraint_ids, int third, int from, int to) {
+    /*
+        This method writes the summation of all the C2 constraints for a certain ~vX_xFROM_xTO
+        --> 'third' is the variable number of vN_xFROM_xTO
+    */
+    if(constraint_ids.size() > 1) {
+
+        // Need to keep track of coeff for vN_xFROM_xTO
+        int total_coeff = 0;
+
+        // Write first two manually
+        Expression* expression = new Operation(new Single(constraint_ids[0]), new Single(constraint_ids[1]), "+");
+        total_coeff += coeff_store.find(constraint_ids[0]) != coeff_store.end() ? coeff_store[constraint_ids[0]] : 1; 
+        total_coeff += coeff_store.find(constraint_ids[1]) != coeff_store.end() ? coeff_store[constraint_ids[1]] : 1; 
+
+        // Loop for others
+        for(int i = 2; i < constraint_ids.size(); i++) {
+            expression = new Operation(expression, new Single(constraint_ids[i]), "+");
+            total_coeff += coeff_store.find(constraint_ids[i]) != coeff_store.end() ? coeff_store[constraint_ids[i]] : 1;
+        }
+        tree_derivation.push(expression);
+        tree_constraint_counter++;
+
+        // Store resulting constraint id
+        constraint_store[third] = -tree_constraint_counter;
+
+        // Store sum of coeffs 
+        coeff_store[-tree_constraint_counter] = total_coeff;
+    }
+}
+
+int Prooflogger::write_C_sub_red(vec<Lit>& definition, int sigma, int from, int to) {
+    /*
+        This method writes the substitution redundancy line for C1 and C2 constraints
+        --> it keeps track of meaning full names
+        --> if simplify is set to true it automatically skips trivially true constraints and unit variables
+        --> through summing with previous C2's it resolves variables such that veripb gets the actual cardinality constraints
+    */
+
+    if(simplify) {
+        // First verify if clause should be written at all
+        for (int i = 0; i < definition.size(); i++) {
+            // If the sign is the same as the one in the store then the clause is trivially true
+            if(unit_store.find(var(definition[i])) != unit_store.end() && unit_store[var(definition[i])] == sign(definition[i])) return -1;
+        }
+    }
+
+    if(meaningful_names) {
+        int first = var(definition[0]);
+        int second = var(definition[1]); 
+        int third = var(definition[2]);
+
+        // If variable does not already have a meaningful name
+        if(meaningful_name_LB.find(third) == meaningful_name_LB.end()) {
+            meaningful_name_LB[third] = from+1;
+            meaningful_name_UB[third] = to+1;
+            meaningful_name_n[third] = sigma;
+        }
+    }
+
+    // Write sub red line
+    std::string variable;
+    proof<< "red ";
+    for (int i = 0; i < definition.size(); i++) {
+        
+        // If the literal is now found in the store then its sign was different, hence it shouldn't be written 
+        if(!simplify || unit_store.find(var(definition[i])) == unit_store.end()) {
+            write_literal(definition[i]);
+        }
+    }
+    proof << " >= 1;";
+    write_witness(definition[2]);
+    proof << "\n";
+    constraint_counter++;
+
+    // Only resolve C2's and don't resolve v0_xFROM_xTO because they can be unit propagated
+    if(sign(definition[2]) == 1 && sigma > 0) {
+        int first = var(definition[0]);
+        int second = var(definition[1]);
+        int third = var(definition[2]);
+        bool resolved_one = false;
+
+        // If first needs to be resolved
+        if(first > formula_length + n_variables && constraint_store.find(first) != constraint_store.end()) {
+            resolved_one = true;
+            int first_constraint_id = constraint_store[first];
+            int first_coeff = coeff_store.find(first_constraint_id) != coeff_store.end()? coeff_store[first_constraint_id] : 1;
+
+            tree_derivation.push(new Operation(new Operation(new Single(constraint_counter), new Single(first_coeff), "*"),
+                                                new Single(first_constraint_id),
+                                                "+"));
+            tree_constraint_counter++;
+            coeff_store[tree_constraint_counter] = first_coeff;
+        }
+
+        // If second needs to be resolved
+        if(second > formula_length + n_variables && constraint_store.find(second) != constraint_store.end()) {
+            resolved_one = true;
+            int second_constraint_id = constraint_store[second];
+            int second_coeff = coeff_store.find(second_constraint_id) != coeff_store.end()? coeff_store[second_constraint_id] : 1;
+            int third_coeff = coeff_store.find(constraint_counter) != coeff_store.end()? coeff_store[constraint_counter] : 1;
+
+            tree_derivation.push(new Operation(new Operation(new Single(constraint_counter), new Single(second_coeff), "*"),
+                                                new Operation(new Single(second_constraint_id), new Single(third_coeff), "*"),
+                                                "+"));
+            tree_constraint_counter++;
+            coeff_store[tree_constraint_counter] = third_coeff * second_coeff;
+        }
+
+        // If no resolving had to be done
+        if(resolved_one) constraint_store[third] -tree_constraint_counter;
+        else constraint_store[third] = constraint_counter;
+    }
+    return constraint_counter;
+}
+
+//=================================================================================================
+// OPB file
+
+void Prooflogger::write_OPB_header(int nbvar, int nbclause) {
+    formula_length = nbclause;
+    n_variables = nbvar;
+    OPB_file << "* #variable= " << nbvar+nbclause << " #constraint= " << nbclause << "\n";
+    OPB_file << "*\n* This MaxSAT instance was automatically generated.\n*\n";
+}
+
+void Prooflogger::write_minimise(int start_var, int num) {
+    if(num > 0) {
+        OPB_file << "min: ";
+        for(int i = start_var+1; i < start_var+num+1; i++) {
+            OPB_file << "1 x" << i << " ";
+        } 
+        OPB_file << ";\n";
+    }
+}
+
+void Prooflogger::write_OPB_constraint(vec<Lit>& constraint, int weight) {
+    for (int i = 0; i < constraint.size(); i++) {
+        if (sign(constraint[i]) == 1)
+            constraints << "1 ~x" << var(constraint[i]) + 1 << " ";
+        else
+            constraints << "1 x" << var(constraint[i]) + 1 << " ";
+    }
+    constraints << " >= " << weight << " ;\n";
+}
+
+
+
+std::string Operation::apply(int constraint_id_at_start_of_printing) {
+    //Operation(Expression* a, Expression* b, const char* operant)
+    return a->apply(constraint_id_at_start_of_printing) + " " 
+                + b->apply(constraint_id_at_start_of_printing) 
+                + " " + this->operant ;
+}
+
+std::string Single::apply(int constraint_id_at_start_of_printing){
+    std::cout << this->constraint_id << "\n";
+    return std::to_string(this->constraint_id < 0 ? abs(this->constraint_id) +  constraint_id_at_start_of_printing : this->constraint_id);
+}
\ No newline at end of file
diff -ruN src_tmp/core/Prooflogger.h src/core/Prooflogger.h
--- src_tmp/core/Prooflogger.h	1970-01-01 01:00:00.000000000 +0100
+++ src/core/Prooflogger.h	2021-12-26 19:46:59.736756300 +0100
@@ -0,0 +1,130 @@
+#ifndef Prooflogger_h
+#define Prooflogger_h
+
+#include <cstdio>
+#include <fstream>
+#include <iostream>
+#include <sstream>
+#include <map>
+#include <string>
+#include <regex>
+
+#include "Vec.h"
+#include "Heap.h"
+#include "Alg.h"
+
+#include "SolverTypes.h"
+
+//=================================================================================================
+// Prooflogger -- polish notation class:
+
+class Expression {
+public:
+    virtual std::string apply(int constraint_id_at_start_of_printing){};
+};
+
+class Single : public Expression {
+public:
+    Single(int constraint_id);
+
+    // Constraint id
+    //
+    int constraint_id;
+
+    std::string apply(int constraint_id_at_start_of_printing) override;
+};
+
+class Operation : public Expression {
+public:
+    Operation(Expression* a, Expression* b, const char* operant);
+
+    // Operands
+    //
+    Expression* a;
+    Expression* b;
+
+    // Operant
+    //
+    std::string operant;
+
+    // Apply
+    //
+    std::string apply(int constraint_id_at_start_of_printing) override;
+};
+
+
+//=================================================================================================
+// Prooflogger -- the main class:
+
+
+class Prooflogger {
+public:
+
+    // Formula information
+    //
+    int formula_length = 0;
+    int n_variables = 0;
+
+    // Constraint counter
+    //
+    int constraint_counter = 0;
+    int last_bound_constraint_id;
+
+    // Tree derivation
+    //
+    int tree_constraint_counter = 0;
+    vec<Expression*> tree_derivation;
+
+    // Simplified constraint store
+    // 
+    bool simplify = false;
+    std::map<int, int> unit_store;
+
+    // Meaningful variable names
+    bool meaningful_names = false;
+    std::map<int, int> meaningful_name_LB;
+    std::map<int, int> meaningful_name_UB;
+    std::map<int, int> meaningful_name_n;
+
+    // Constraint and coeff store
+    //
+    std::map<int, int> constraint_store;
+    std::map<int, int> coeff_store;
+
+    // Proof file
+    std::stringstream proof;
+    const char *proof_file_name = "maxsat_proof.pbp";
+    void set_proof_name             (const char* name) {proof_file_name = name;};
+    void write_proof_file           ();
+    void write_tree_derivation      ();
+    void write_proof_header         (int nbclause);
+    void write_comment              (const char* comment);
+    void write_contradiction        ();
+    void write_empty_clause         ();
+    bool is_aux_var                 (int var); 
+    void write_literal              (Lit literal);
+    void write_literal_assignment   (lbool assignment, int var);
+    void write_witness              (Lit literal);
+    void write_clause               (vec<Lit>& clause);
+    void write_learnt_clause        (vec<Lit>& clause);
+    void write_linkingVar_clause    (vec<Lit>& clause);
+    void write_bound_update         (vec<lbool>& model); 
+    void write_unit_sub_red         (vec<Lit>& definition);
+    void write_C2_sum               (vec<int>& constraint_ids, int third, int from, int to);
+    int write_C_sub_red             (vec<Lit>& definition, int sigma, int from, int to);
+
+    // OPB file
+    std::ofstream OPB_file;
+    std::stringstream constraints;
+    const char *OPB_file_name = "maxsat_problem.opb";
+    void open_OPB                 ()                   {OPB_file.open(OPB_file_name);};
+    void close_OPB                ()                   {OPB_file << constraints.rdbuf(); OPB_file.close();};
+    void set_OPB_name             (const char* name)   {OPB_file_name = name;};
+
+    void write_OPB_header         (int nbvar, int nbclause);
+    void write_minimise           (int start_var, int num);
+    void write_OPB_constraint     (vec<Lit>& constraint, int weight);
+};
+
+//=================================================================================================
+#endif
\ No newline at end of file
diff -ruN src_tmp/core/Solver.C src/core/Solver.C
--- src_tmp/core/Solver.C	2021-12-26 20:06:51.201071700 +0100
+++ src/core/Solver.C	2021-12-26 11:37:17.936500100 +0100
@@ -26,7 +26,7 @@
 // Constructor/Destructor:
 
 
-Solver::Solver() :
+Solver::Solver(Prooflogger *PL) :
 
     // Parameters: (formerly in 'SearchParams')
     var_decay(1 / 0.95), clause_decay(1 / 0.999), random_var_freq(0.02)
@@ -53,6 +53,10 @@
   , random_seed      (91648253)
   , progress_estimate(0)
   , remove_satisfied (true)
+
+  // Prooflogger
+  //
+  , PL(PL)
 {}
 
 
@@ -544,7 +548,7 @@
 |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
 |    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
 |________________________________________________________________________________________________@*/
-lbool Solver::search(int nof_conflicts, int nof_learnts)
+lbool Solver::search(int nof_conflicts, int nof_learnts) 
 {
     assert(ok);
     int         backtrack_level;
@@ -560,12 +564,19 @@
         if (confl != NULL){
             // CONFLICT
             conflicts++; conflictC++;
-            if (decisionLevel() == 0) return l_False;
+            if (decisionLevel() == 0) {
+                PL->write_empty_clause();
+                return l_False;
+            }
 
             first = false;
 
             learnt_clause.clear();
             analyze(confl, learnt_clause, backtrack_level);
+
+            // Write the learnt clause to the proof file
+            PL->write_learnt_clause(learnt_clause);
+
             cancelUntil(backtrack_level);
             assert(value(learnt_clause[0]) == l_Undef);
 
@@ -592,8 +603,10 @@
                 return l_Undef; }
 
             // Simplify the set of problem clauses:
-            if (decisionLevel() == 0 && !simplify())
+            if (decisionLevel() == 0 && !simplify()) {
+                PL->write_empty_clause();
                 return l_False;
+            }
 
             if (nof_learnts >= 0 && learnts.size()-nAssigns() >= nof_learnts)
                 // Reduce the set of learnt clauses:
@@ -654,7 +667,10 @@
     model.clear();
     conflict.clear();
 
-    if (!ok) return false;
+    if (!ok) {
+        PL->write_empty_clause();
+        return false;
+    }
 
     assumps.copyTo(assumptions);
 
diff -ruN src_tmp/core/Solver.h src/core/Solver.h
--- src_tmp/core/Solver.h	2021-12-26 20:06:51.200156800 +0100
+++ src/core/Solver.h	2021-12-22 10:25:15.730665200 +0100
@@ -21,12 +21,15 @@
 #define Solver_h
 
 #include <cstdio>
+#include <fstream>
+#include <iostream>
 
 #include "Vec.h"
 #include "Heap.h"
 #include "Alg.h"
 
 #include "SolverTypes.h"
+#include "Prooflogger.h"
 
 
 //=================================================================================================
@@ -38,9 +41,13 @@
 
     // Constructor/Destructor:
     //
-    Solver();
+    Solver(Prooflogger *PL);
     ~Solver();
 
+    // Proof logging:
+    //
+    Prooflogger* PL;
+
     // Problem specification:
     //
     Var     newVar    (bool polarity = true, bool dvar = true); // Add a new variable with parameters specifying variable mode.
@@ -146,19 +153,19 @@
 
     // Main internal methods:
     //
-    void     insertVarOrder   (Var x);                                                 // Insert a variable in the decision order priority queue.
-    Lit      pickBranchLit    (int polarity_mode, double random_var_freq);             // Return the next decision variable.
-    void     newDecisionLevel ();                                                      // Begins a new decision level.
-    void     uncheckedEnqueue (Lit p, Clause* from = NULL);                            // Enqueue a literal. Assumes value of literal is undefined.
-    bool     enqueue          (Lit p, Clause* from = NULL);                            // Test if fact 'p' contradicts current state, enqueue otherwise.
-    Clause*  propagate        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
-    void     cancelUntil      (int level);                                             // Backtrack until a certain level.
-    void     analyze          (Clause* confl, vec<Lit>& out_learnt, int& out_btlevel); // (bt = backtrack)
-    void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
-    bool     litRedundant     (Lit p, uint32_t abstract_levels);                       // (helper method for 'analyze()')
-    lbool    search           (int nof_conflicts, int nof_learnts);                    // Search for a given number of conflicts.
-    void     reduceDB         ();                                                      // Reduce the set of learnt clauses.
-    void     removeSatisfied  (vec<Clause*>& cs);                                      // Shrink 'cs' to contain only non-satisfied clauses.
+    void     insertVarOrder   (Var x);                                                  // Insert a variable in the decision order priority queue.
+    Lit      pickBranchLit    (int polarity_mode, double random_var_freq);              // Return the next decision variable.
+    void     newDecisionLevel ();                                                       // Begins a new decision level.
+    void     uncheckedEnqueue (Lit p, Clause* from = NULL);                             // Enqueue a literal. Assumes value of literal is undefined.
+    bool     enqueue          (Lit p, Clause* from = NULL);                             // Test if fact 'p' contradicts current state, enqueue otherwise.
+    Clause*  propagate        ();                                                       // Perform unit propagation. Returns possibly conflicting clause.
+    void     cancelUntil      (int level);                                              // Backtrack until a certain level.
+    void     analyze          (Clause* confl, vec<Lit>& out_learnt, int& out_btlevel);  // (bt = backtrack)
+    void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                          // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
+    bool     litRedundant     (Lit p, uint32_t abstract_levels);                        // (helper method for 'analyze()')
+    lbool    search           (int nof_conflicts, int nof_learnts);                     // Search for a given number of conflicts.
+    void     reduceDB         ();                                                       // Reduce the set of learnt clauses.
+    void     removeSatisfied  (vec<Clause*>& cs);                                       // Shrink 'cs' to contain only non-satisfied clauses.
 
     // Maintaining Variable/Clause activity:
     //
