diff -ruN src_tmp/core/Main.C src/core/Main.C
--- src_tmp/core/Main.C	2021-11-29 14:36:13.361450103 +0100
+++ src/core/Main.C	2021-11-29 14:36:06.581436536 +0100
@@ -27,6 +27,7 @@
 #include <zlib.h>
 
 #include "Solver.h"
+#include "Prooflogger.h"
 
 /*************************************************************************************/
 #ifdef _MSC_VER
@@ -131,10 +132,10 @@
     return neg ? -val : val; }
 
 template<class B>
-static void readClause(B& in, Solver& S, vec<Lit>& lits, 
+static void readClause(B& in, Solver& S, Prooflogger &PL, vec<Lit>& lits, 
 		       int nbvar, int top, int& nbsoft) { // koshi 10.01.04
 
-    int     parsed_lit, var;
+    int parsed_lit, var;
     lits.clear();
     parsed_lit = parseInt(in); // koshi 10.01.04
     if (parsed_lit == 1) { // soft clause
@@ -151,6 +152,9 @@
 	// koshi 10.01.04        while (var >= S.nVars()) S.newVar();
         lits.push( (parsed_lit > 0) ? Lit(var) : ~Lit(var) );
     }
+
+    // Write the whole as a subsitution redundancy line in the proof file
+    PL.write_sub_red(lits, 0);
 }
 
 template<class B>
@@ -163,42 +167,51 @@
 
 
 template<class B>
-static void parse_DIMACS_main(B& in, Solver& S, 
+static void parse_DIMACS_main(B& in, Solver& S, Prooflogger &PL, 
 			      int& out_nbvar, int& out_top, int& out_nbsoft) {
     vec<Lit> lits;
+
+    // Read header
+    skipWhitespace(in);
+    if (*in == 'p'){
+	     if (match(in, "p wcnf")){ // koshi 10.01.04
+            int vars    = parseInt(in);
+            int clauses = parseInt(in);
+		      int top     = parseInt(in);
+		      out_nbvar   = vars;
+		      out_top     = top;
+            reportf("|  Number of variables:    %-12d                                       |\n", vars);
+            reportf("|  Number of clauses:      %-12d                                       |\n", clauses);
+            reportf("|  Weight of hard clauses: %-12d                                       |\n", top);
+            PL.write_header(clauses);
+		    while (vars > S.nVars()) S.newVar();
+        } else {
+            reportf("PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
+        }
+    } else reportf("PARSE ERROR! No header given!");
+
+    // Read clauses
+    PL.write_comment("Adding blocking variables using substitution redundancy:\n");
     for (;;){
         skipWhitespace(in);
         if (*in == EOF)
             break;
-        else if (*in == 'p'){
-	  if (match(in, "p wcnf")){ // koshi 10.01.04
-                int vars    = parseInt(in);
-                int clauses = parseInt(in);
-		int top     = parseInt(in);
-		out_nbvar   = vars;
-		out_top     = top;
-                reportf("|  Number of variables:    %-12d                                       |\n", vars);
-                reportf("|  Number of clauses:      %-12d                                       |\n", clauses);
-                reportf("|  Weight of hard clauses: %-12d                                       |\n", top);
-		while (vars > S.nVars()) S.newVar();
-            }else{
-                reportf("PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
-            }
-        } else if (*in == 'c' || *in == 'p')
-            skipLine(in);
-        else
-	  readClause(in, S, lits, out_nbvar,out_top,out_nbsoft),
+        else if (*in == 'c' || *in == 'p') skipLine(in);
+        else {
+	        readClause(in, S, PL, lits, out_nbvar,out_top,out_nbsoft),
             S.addClause(lits);
+        }
     }
     reportf("|  Number of soft clauses: %-12d                                       |\n", out_nbsoft);
+    PL.write_comment("==============================================================\n");
 }
 
 // Inserts problem into solver.
 //
-static void parse_DIMACS(gzFile input_stream, Solver& S, 
+static void parse_DIMACS(gzFile input_stream, Solver& S, Prooflogger &PL, 
 			 int& out_nbvar, int& out_top, int& out_nbsoft) { // koshi 10.01.04
     StreamBuffer in(input_stream);
-    parse_DIMACS_main(in, S, out_nbvar, out_top, out_nbsoft); }
+    parse_DIMACS_main(in, S, PL, out_nbvar, out_top, out_nbsoft); }
 
 
 //=================================================================================================
@@ -236,6 +249,7 @@
     reportf("  -decay         = <num> [ 0 - 1 ]\n");
     reportf("  -rnd-freq      = <num> [ 0 - 1 ]\n");
     reportf("  -verbosity     = {0,1,2}\n");
+    reportf("  -proof-file    = /path/to/proof_file.proof (default: maxsat_proof.proof)");
     reportf("\n");
 }
 
@@ -249,9 +263,11 @@
         return NULL;
 }
 
+
+
 // koshi 10.01.08
 void genCardinals(int from, int to, 
-		  Solver& S, vec<Lit>& lits, vec<Lit>& linkingVar) {
+		  Solver& S, Prooflogger& PL, vec<Lit>& lits, vec<Lit>& linkingVar) {
   int inputSize = to - from + 1;
   linkingVar.clear();
 
@@ -266,11 +282,11 @@
 
   if (inputSize > 2) {
     int middle = inputSize/2;
-    genCardinals(from, from+middle, S,lits,linkingAlpha);
-    genCardinals(from+middle+1, to, S,lits,linkingBeta);
+    genCardinals(from, from+middle, S,PL,lits,linkingAlpha);
+    genCardinals(from+middle+1, to, S,PL,lits,linkingBeta);
   } else if (inputSize == 2) {
-    genCardinals(from, from, S,lits,linkingAlpha);
-    genCardinals(to, to, S,lits,linkingBeta);
+    genCardinals(from, from, S,PL,lits,linkingAlpha);
+    genCardinals(to, to, S,PL,lits,linkingBeta);
   }
   if (inputSize == 1) {
     linkingVar.push(Lit(varZero));
@@ -304,10 +320,10 @@
 
 int main(int argc, char** argv)
 {
-    Solver      S;
+    Prooflogger PL;
+    Solver      S(&PL);
     S.verbosity = 1;
 
-
     int         i, j;
     const char* value;
     for (i = j = 0; i < argc; i++){
@@ -347,6 +363,9 @@
             printUsage(argv);
             exit(0);
 
+        } else if ((value = hasPrefix(argv[i], "-proof-file="))) {
+            PL.set_name(value);
+
         }else if (strncmp(argv[i], "-", 1) == 0){
             reportf("ERROR! unknown flag %s\n", argv[i]);
             exit(0);
@@ -376,6 +395,9 @@
     if (in == NULL)
         reportf("ERROR! Could not open file: %s\n", argc == 1 ? "<stdin>" : argv[1]), exit(1);
 
+    // Open proof file
+    PL.open();
+
     reportf("============================[ Problem Statistics ]=============================\n");
     reportf("|                                                                             |\n");
 
@@ -383,16 +405,20 @@
     int nbvar  = 0; // number of original variables
     int top    = 0; // weight of hard clause
     int nbsoft = 0; // number of soft clauses
-    parse_DIMACS(in, S, nbvar, top, nbsoft);
+    parse_DIMACS(in, S, PL, nbvar, top, nbsoft);
     gzclose(in);
     FILE* res = (argc >= 3) ? fopen(argv[2], "wb") : NULL;
 
+    PL.constraint_counter = S.nClauses();
+
     double parse_time = cpuTime() - cpu_time;
     reportf("|  Parsing time:         %-12.2f s                                       |\n", parse_time);
 
     if (!S.simplify()){
         reportf("Solved by unit propagation\n");
         if (res != NULL) fprintf(res, "UNSAT\n"), fclose(res);
+        PL.derived_empty_clause();
+        PL.close();
         printf("UNSATISFIABLE\n");
         exit(20);
     }
@@ -402,6 +428,7 @@
     int lcnt = 0; // loop count
     vec<Lit> linkingVar;
  solve:
+    PL.constraint_counter = S.nClauses();
     bool ret = S.solve();
     if (ret) { // koshi 09.12.25
       lcnt++;
@@ -409,19 +436,23 @@
       for (int i = nbvar; i < nbvar+nbsoft; i++) // count the number of
 	if (S.model[i] == l_True) answerNew++;   // unsatisfied soft clauses
       if (lcnt == 1) { // first model: generate cardinal constraints
-	genCardinals(nbvar,nbvar+nbsoft-1, S,lits,linkingVar);
+	genCardinals(nbvar,nbvar+nbsoft-1, S,PL,lits,linkingVar);
 	for (int i = answerNew; i < linkingVar.size()-1; i++) {
 	  lits.clear();
 	  lits.push(~linkingVar[i]);
 	  S.addClause(lits);
+      PL.write_learnt_clause(lits);
 	}
+
 	answer = answerNew;
       } else { // lcnt > 1 
 	for (int i = answerNew; i < answer; i++) {
 	  lits.clear();
 	  lits.push(~linkingVar[i]);
 	  S.addClause(lits);
+      PL.write_learnt_clause(lits);
 	}
+
 	answer = answerNew;
       }
       reportf("Current answer = %d\n",answer);
@@ -441,6 +472,7 @@
             fprintf(res, " 0\n");
         }else
             fprintf(res, "UNSAT\n");
+        PL.close();
         fclose(res);
     }
 
diff -ruN src_tmp/core/Prooflogger.C src/core/Prooflogger.C
--- src_tmp/core/Prooflogger.C	1970-01-01 01:00:00.000000000 +0100
+++ src/core/Prooflogger.C	2021-11-29 14:33:53.101104643 +0100
@@ -0,0 +1,67 @@
+#include "Prooflogger.h"
+
+//=================================================================================================
+// File methods
+
+void Prooflogger::open()
+{
+    proof_file.open(proof_file_name);
+}
+
+void Prooflogger::close()
+{
+    proof_file.close();
+}
+
+void Prooflogger::set_name(const char* new_name)
+{
+    proof_file_name = new_name;
+}
+
+
+//=================================================================================================
+// Writing methods
+
+
+void Prooflogger::write_header(int nClauses) {
+    proof_file << "pseudo-Boolean proof version 1.0\n";
+    proof_file << "f " << nClauses << ";\n";
+}
+
+void Prooflogger::write_comment(const char* comment) {
+    proof_file << "\nc " << comment << "\n";
+}
+
+void Prooflogger::derived_empty_clause() {
+    proof_file << "u >= 1;\n";
+    constraint_counter++;
+    write_contradiction();
+}
+
+void Prooflogger::write_sub_red(vec<Lit>& definition, bool ass) {
+    proof_file << "red ";
+    for (int i = 1; i < definition.size(); i++) {
+        if (sign(definition[i]) == 1)
+            proof_file << "1 ~x" << var(definition[i]) + 1 << " ";
+        else
+            proof_file << "1 x" << var(definition[i]) + 1 << " ";
+    }
+    proof_file << "1 y" << var(definition[0])+1 << " >= 1; y" << var(definition[0])+1 << " -> " << ass << "\n";
+    constraint_counter++;
+}
+
+void Prooflogger::write_learnt_clause(vec<Lit>& clause) {
+    proof_file << "u ";
+    for (int i = 0; i < clause.size(); i++) {
+        if (sign(clause[i]) == 1)
+            proof_file << "1 ~x" << var(clause[i]) + 1 << " ";
+        else
+            proof_file << "1 x" << var(clause[i]) + 1 << " ";
+    }
+    proof_file << " >= 1;\n";
+    constraint_counter++;
+}
+
+void Prooflogger::write_contradiction() {
+    proof_file << "c " << constraint_counter;
+}
\ No newline at end of file
diff -ruN src_tmp/core/Prooflogger.h src/core/Prooflogger.h
--- src_tmp/core/Prooflogger.h	1970-01-01 01:00:00.000000000 +0100
+++ src/core/Prooflogger.h	2021-11-29 14:33:09.260955813 +0100
@@ -0,0 +1,46 @@
+#ifndef Prooflogger_h
+#define Prooflogger_h
+
+#include <cstdio>
+#include <fstream>
+#include <iostream>
+
+#include "Vec.h"
+#include "Heap.h"
+#include "Alg.h"
+
+#include "SolverTypes.h"
+
+
+//=================================================================================================
+// Prooflogger -- the main class:
+
+
+class Prooflogger {
+public:
+
+    // Constrain counter
+    //
+    int constraint_counter = 0;
+
+    // Proof file
+    std::ofstream proof_file;
+    const char *proof_file_name = "maxsat_proof.proof";
+    void open                 ();
+    void close                ();
+    void set_name             (const char* name);
+    
+    // Printing functions
+    //
+    void write_header         (int nClauses);
+    void write_comment        (const char* comment);
+    void derived_empty_clause ();
+    void write_learnt_clause  (vec<Lit>& clause);
+    void write_sub_red        (vec<Lit>& definition, bool ass);
+    void write_constraint     (vec<Lit>& clause);
+    void write_contradiction  ();
+
+};
+
+//=================================================================================================
+#endif
\ No newline at end of file
diff -ruN src_tmp/core/Solver.C src/core/Solver.C
--- src_tmp/core/Solver.C	2021-11-29 14:36:13.361450103 +0100
+++ src/core/Solver.C	2021-11-27 11:30:38.696712462 +0100
@@ -26,7 +26,7 @@
 // Constructor/Destructor:
 
 
-Solver::Solver() :
+Solver::Solver(Prooflogger *PL) :
 
     // Parameters: (formerly in 'SearchParams')
     var_decay(1 / 0.95), clause_decay(1 / 0.999), random_var_freq(0.02)
@@ -53,6 +53,10 @@
   , random_seed      (91648253)
   , progress_estimate(0)
   , remove_satisfied (true)
+
+  // Prooflogger
+  //
+  , PL(PL)
 {}
 
 
@@ -544,7 +548,7 @@
 |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
 |    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
 |________________________________________________________________________________________________@*/
-lbool Solver::search(int nof_conflicts, int nof_learnts)
+lbool Solver::search(int nof_conflicts, int nof_learnts) 
 {
     assert(ok);
     int         backtrack_level;
@@ -560,12 +564,19 @@
         if (confl != NULL){
             // CONFLICT
             conflicts++; conflictC++;
-            if (decisionLevel() == 0) return l_False;
+            if (decisionLevel() == 0) {
+                PL->derived_empty_clause();
+                return l_False;
+            }
 
             first = false;
 
             learnt_clause.clear();
             analyze(confl, learnt_clause, backtrack_level);
+
+            // Write the learnt clause to the proof file
+            PL->write_learnt_clause(learnt_clause);
+
             cancelUntil(backtrack_level);
             assert(value(learnt_clause[0]) == l_Undef);
 
@@ -592,8 +603,10 @@
                 return l_Undef; }
 
             // Simplify the set of problem clauses:
-            if (decisionLevel() == 0 && !simplify())
+            if (decisionLevel() == 0 && !simplify()) {
+                PL->derived_empty_clause();
                 return l_False;
+            }
 
             if (nof_learnts >= 0 && learnts.size()-nAssigns() >= nof_learnts)
                 // Reduce the set of learnt clauses:
@@ -654,7 +667,10 @@
     model.clear();
     conflict.clear();
 
-    if (!ok) return false;
+    if (!ok) {
+        PL->derived_empty_clause();
+        return false;
+    }
 
     assumps.copyTo(assumptions);
 
diff -ruN src_tmp/core/Solver.h src/core/Solver.h
--- src_tmp/core/Solver.h	2021-11-29 14:36:13.361450103 +0100
+++ src/core/Solver.h	2021-11-27 11:28:03.309903975 +0100
@@ -21,12 +21,15 @@
 #define Solver_h
 
 #include <cstdio>
+#include <fstream>
+#include <iostream>
 
 #include "Vec.h"
 #include "Heap.h"
 #include "Alg.h"
 
 #include "SolverTypes.h"
+#include "Prooflogger.h"
 
 
 //=================================================================================================
@@ -38,9 +41,13 @@
 
     // Constructor/Destructor:
     //
-    Solver();
+    Solver(Prooflogger *PL);
     ~Solver();
 
+    // Proof logging:
+    //
+    Prooflogger* PL;
+
     // Problem specification:
     //
     Var     newVar    (bool polarity = true, bool dvar = true); // Add a new variable with parameters specifying variable mode.
@@ -146,19 +153,19 @@
 
     // Main internal methods:
     //
-    void     insertVarOrder   (Var x);                                                 // Insert a variable in the decision order priority queue.
-    Lit      pickBranchLit    (int polarity_mode, double random_var_freq);             // Return the next decision variable.
-    void     newDecisionLevel ();                                                      // Begins a new decision level.
-    void     uncheckedEnqueue (Lit p, Clause* from = NULL);                            // Enqueue a literal. Assumes value of literal is undefined.
-    bool     enqueue          (Lit p, Clause* from = NULL);                            // Test if fact 'p' contradicts current state, enqueue otherwise.
-    Clause*  propagate        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
-    void     cancelUntil      (int level);                                             // Backtrack until a certain level.
-    void     analyze          (Clause* confl, vec<Lit>& out_learnt, int& out_btlevel); // (bt = backtrack)
-    void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
-    bool     litRedundant     (Lit p, uint32_t abstract_levels);                       // (helper method for 'analyze()')
-    lbool    search           (int nof_conflicts, int nof_learnts);                    // Search for a given number of conflicts.
-    void     reduceDB         ();                                                      // Reduce the set of learnt clauses.
-    void     removeSatisfied  (vec<Clause*>& cs);                                      // Shrink 'cs' to contain only non-satisfied clauses.
+    void     insertVarOrder   (Var x);                                                  // Insert a variable in the decision order priority queue.
+    Lit      pickBranchLit    (int polarity_mode, double random_var_freq);              // Return the next decision variable.
+    void     newDecisionLevel ();                                                       // Begins a new decision level.
+    void     uncheckedEnqueue (Lit p, Clause* from = NULL);                             // Enqueue a literal. Assumes value of literal is undefined.
+    bool     enqueue          (Lit p, Clause* from = NULL);                             // Test if fact 'p' contradicts current state, enqueue otherwise.
+    Clause*  propagate        ();                                                       // Perform unit propagation. Returns possibly conflicting clause.
+    void     cancelUntil      (int level);                                              // Backtrack until a certain level.
+    void     analyze          (Clause* confl, vec<Lit>& out_learnt, int& out_btlevel);  // (bt = backtrack)
+    void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                          // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
+    bool     litRedundant     (Lit p, uint32_t abstract_levels);                        // (helper method for 'analyze()')
+    lbool    search           (int nof_conflicts, int nof_learnts);                     // Search for a given number of conflicts.
+    void     reduceDB         ();                                                       // Reduce the set of learnt clauses.
+    void     removeSatisfied  (vec<Clause*>& cs);                                       // Shrink 'cs' to contain only non-satisfied clauses.
 
     // Maintaining Variable/Clause activity:
     //
